import GameServer.Commands

namespace Predicate

World "Predicate"
Level 4
Title "Existential Elimination"

Introduction "
You've seen how to *prove* that something exists. Now letâ€™s see how to *use* such a fact.

Suppose you're told:

> \"There exists an `x` such that `P(x)` is true\" â€” written as `âˆƒ x, P(x)`

This means:
> \"Some value satisfies the property `P` â€” but we donâ€™t know which one yet.\"

To work with this, we can use the `cases` tactic to:
1. Pull out a specific witness - `x`.
2. Pull out the proof that this witness satisfies `P` - `hx`.

This is called **existential elimination**.

*Note: `P x` and `P (x)` mean the same thing â€” Lean just omits the parentheses by default.*
"


Statement {Î± : Type} (P : Î± â†’ Prop) (Q : Prop) (h : âˆƒ w, P w) (hQ : âˆ€ w, P w â†’ Q) : Q := by
Hint "Use `cases h` to extract the witness `w` and the proof `h_1 : P w`."
cases h with
|intro w h_1 =>
Hint "Now you have `w : Î±` and `h_1 : P w`. Use the universal statement `hQ : âˆ€ w, P w â†’ Q`.

It wouldn't be just `apply hQ`. We also need to specify which element we are working on, which is `w` in this case. So do `apply hQ w`."
apply hQ w
Hint "Lean wants you to prove `P w`, which you have as `h_1`."
exact h_1

Conclusion "
Nice! ðŸŽ‰

You just performed existential elimination:

You started with `âˆƒ w, P (w).`

Then used `cases` to extract a witness and its property and applied a general rule to that specific value.

This is actually one of the most important tools for reasoning about existential statements.
"

end Predicate
