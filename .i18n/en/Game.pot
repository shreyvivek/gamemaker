msgid ""
msgstr "Project-Id-Version: Game v4.7.0\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: Thu Jun 26 21:34:46 2025\n"
"Last-Translator: \n"
"Language-Team: none\n"
"Language: en\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit"

#: GameServer.RpcHandlers
msgid "level completed! 🎉"
msgstr ""

#: GameServer.RpcHandlers
msgid "level completed with warnings… 🎭"
msgstr ""

#: GameServer.RpcHandlers
msgid "intermediate goal solved! 🎉"
msgstr ""

#: Game.Levels.Propositional.L01_AssumeAndFinish
msgid "Assume and Finish"
msgstr ""

#: Game.Levels.Propositional.L01_AssumeAndFinish
msgid "Let’s begin with the simplest task. If you're told `P` is true, then you can conclude `P`.\n"
"\n"
"This teaches you how to use assumptions to finish a goal."
msgstr ""

#: Game.Levels.Propositional.L01_AssumeAndFinish
msgid "Closes the current goal using the exact term you provide.\n"
"\n"
"If your goal is `P` and you have a proof of `P` (say `h : P`), then `exact h` completes the proof.\n"
"\n"
"It’s like saying: “Here’s exactly what you asked for.”"
msgstr ""

#: Game.Levels.Propositional.L01_AssumeAndFinish
msgid "If you know `P`, then you can conclude `P`."
msgstr ""

#: Game.Levels.Propositional.L01_AssumeAndFinish
msgid "Use the `exact` tactic with `«{h}»` to directly prove the goal `P`."
msgstr ""

#: Game.Levels.Propositional.L01_AssumeAndFinish
msgid "You’ve completed your first proof — and yes, it really was that simple!"
msgstr ""

#: Game.Levels.Propositional.L02_IntroduceAssumption
msgid "Introduce Assumption"
msgstr ""

#: Game.Levels.Propositional.L02_IntroduceAssumption
msgid "Let’s prove an implication: `P → P`. That is, if `P` holds, then `P` holds (trivially).\n"
"\n"
"This level introduces the `intro` tactic."
msgstr ""

#: Game.Levels.Propositional.L02_IntroduceAssumption
msgid "Opens up an implication goal by introducing its assumption.\n"
"\n"
"If your goal is `P → Q`, `intro h` changes the goal to `Q` and gives you `h : P` as a local assumption.\n"
"\n"
"Think of it like: “Let’s suppose `P` is true.”"
msgstr ""

#: Game.Levels.Propositional.L02_IntroduceAssumption
msgid "From the assumption `P`, conclude `P`."
msgstr ""

#: Game.Levels.Propositional.L02_IntroduceAssumption
msgid "Use the `intro` tactic to assume `P` is true. Try `intro h`."
msgstr ""

#: Game.Levels.Propositional.L02_IntroduceAssumption
msgid "Now you have `«{h}» : P`, and your goal is `P`. Use `exact` to finish."
msgstr ""

#: Game.Levels.Propositional.L02_IntroduceAssumption
msgid "That was a basic implication! The `intro` tactic is your go-to tool for these."
msgstr ""

#: Game.Levels.Propositional.L03_AndIntroduction
msgid "And Introduction"
msgstr ""

#: Game.Levels.Propositional.L03_AndIntroduction
msgid "From `P` and `Q`, we can conclude `P ∧ Q`. That’s how conjunction works!\n"
"\n"
"You’ll learn the `constructor` tactic in this level."
msgstr ""

#: Game.Levels.Propositional.L03_AndIntroduction
msgid "Used when the goal is a compound proposition like `P ∧ Q`.\n"
"\n"
"It splits the goal into proving both components separately.\n"
"\n"
"For example: `constructor` on `P ∧ Q` gives you two goals — one for `P` and one for `Q`."
msgstr ""

#: Game.Levels.Propositional.L03_AndIntroduction
msgid "From `P` and `Q`, derive `P ∧ Q`."
msgstr ""

#: Game.Levels.Propositional.L03_AndIntroduction
msgid "Use the `constructor` tactic to split the goal `P ∧ Q` into two parts."
msgstr ""

#: Game.Levels.Propositional.L03_AndIntroduction
msgid "Now prove `P` using `«{hp}»`."
msgstr ""

#: Game.Levels.Propositional.L03_AndIntroduction
msgid "Now prove `Q` using `«{hq}»`."
msgstr ""

#: Game.Levels.Propositional.L03_AndIntroduction
msgid "Nice work! You combined two truths into one solid conjunction."
msgstr ""

#: Game.Levels.Propositional.L04_AndEliminationLeft
msgid "And Elimination (Left)"
msgstr ""

#: Game.Levels.Propositional.L04_AndEliminationLeft
msgid "If you know `P ∧ Q`, then you can extract `P` from it.\n"
"\n"
"Let’s see how to do that with `.left`."
msgstr ""

#: Game.Levels.Propositional.L04_AndEliminationLeft
msgid "If you have `h : P ∧ Q`, then:\n"
"\n"
"- `h.left` gives you a proof of `P`.\n"
"- `h.right` gives you a proof of `Q`.\n"
"\n"
"They’re used to “unpack” conjunctions."
msgstr ""

#: Game.Levels.Propositional.L04_AndEliminationLeft
msgid "From `P ∧ Q`, derive `P`."
msgstr ""

#: Game.Levels.Propositional.L04_AndEliminationLeft
msgid "Use `h.left` to extract the left part `P` from `P ∧ Q`."
msgstr ""

#: Game.Levels.Propositional.L04_AndEliminationLeft
msgid "Nicely done! You extracted the left side of a conjunction. A similar procedure can be followed to extract the right half of a conjunction."
msgstr ""

#: Game.Levels.Propositional.L05_OrIntroductionLeft
msgid "Or Introduction (Left)"
msgstr ""

#: Game.Levels.Propositional.L05_OrIntroductionLeft
msgid "If you know `P`, then you can conclude `P ∨ Q`.\n"
"\n"
"Let’s introduce disjunction using the `left` tactic."
msgstr ""

#: Game.Levels.Propositional.L05_OrIntroductionLeft
msgid "For disjunctions (`P ∨ Q`):\n"
"\n"
"- `left` means: “I’ll prove `P`, and that’s enough.”\n"
"- `right` means: “I’ll prove `Q`, and that’s enough.”\n"
"\n"
"Use `left` when you have a proof of `P`, and `right` when you have a proof of `Q`."
msgstr ""

#: Game.Levels.Propositional.L05_OrIntroductionLeft
msgid "From `P`, derive `P ∨ Q`."
msgstr ""

#: Game.Levels.Propositional.L05_OrIntroductionLeft
msgid "Use the `left` tactic to say `P ∨ Q` is true because `P` is true."
msgstr ""

#: Game.Levels.Propositional.L05_OrIntroductionLeft
msgid "Now you can finish the level yourself."
msgstr ""

#: Game.Levels.Propositional.L05_OrIntroductionLeft
msgid "Great! You’ve learned how to state that “at least one is true.”"
msgstr ""

#: Game.Levels.Propositional.L06_OrIntroductionRight
msgid "Or Introduction (Right)"
msgstr ""

#: Game.Levels.Propositional.L06_OrIntroductionRight
msgid "If `Q` is true, then `P ∨ Q` is also true — because *at least one* must hold.\n"
"\n"
"Now let’s learn how to use the `right` tactic."
msgstr ""

#: Game.Levels.Propositional.L06_OrIntroductionRight
msgid "Repeated for clarity.\n"
"\n"
"For disjunctions (`P ∨ Q`):\n"
"\n"
"- `left` means: “I’ll prove `P`, and that’s enough.”\n"
"- `right` means: “I’ll prove `Q`, and that’s enough.”\n"
"\n"
"Use `left` when you have a proof of `P`, and `right` when you have a proof of `Q`."
msgstr ""

#: Game.Levels.Propositional.L06_OrIntroductionRight
msgid "From `Q`, derive `P ∨ Q`."
msgstr ""

#: Game.Levels.Propositional.L06_OrIntroductionRight
msgid "Use the `right` tactic this time, to commit to proving `Q` instead of `P`."
msgstr ""

#: Game.Levels.Propositional.L06_OrIntroductionRight
msgid "Now finish the proof by showing `Q` holds using `«{h}»`."
msgstr ""

#: Game.Levels.Propositional.L06_OrIntroductionRight
msgid "Great! You've mastered both left and right disjunction introduction."
msgstr ""

#: Game.Levels.Propositional.L07_OrElimination
msgid "Or Elimination"
msgstr ""

#: Game.Levels.Propositional.L07_OrElimination
msgid "If you know `P ∨ Q`, and you can show `R` follows from each of them individually, then you can conclude `R`.\n"
"\n"
"This is a form of case analysis — we’ll use the `cases` tactic."
msgstr ""

#: Game.Levels.Propositional.L07_OrElimination
msgid "The `cases` tactic lets you do case analysis on a disjunction.\n"
"\n"
"If you have `h : P ∨ Q`, then `cases h with | inl hp => ... | inr hq => ...` creates two branches:\n"
"- One where `P` is assumed true (`hp`)\n"
"- One where `Q` is assumed true (`hq`)\n"
"\n"
"You must prove the goal in both branches."
msgstr ""

#: Game.Levels.Propositional.L07_OrElimination
msgid "From `P ∨ Q`, and knowing both imply `R`, conclude `R`."
msgstr ""

#: Game.Levels.Propositional.L07_OrElimination
msgid "Use the `cases` tactic to break the disjunction `«{h}»` into two possible cases."
msgstr ""

#: Game.Levels.Propositional.L07_OrElimination
msgid "You are now in the case where `P` holds. Use `«{h₁}»` to get `R`. Try using `exact` with a combination of assumptions."
msgstr ""

#: Game.Levels.Propositional.L07_OrElimination
msgid "Now `Q` holds. Use `«{h₂}»` to conclude `R`."
msgstr ""

#: Game.Levels.Propositional.L07_OrElimination
msgid "You've learned **disjunction elimination** — case-by-case reasoning using `∨`."
msgstr ""

#: Game.Levels.Propositional.L08_ImplicationChain
msgid "Implication Chain"
msgstr ""

#: Game.Levels.Propositional.L08_ImplicationChain
msgid "Suppose you know two implications:\n"
"\n"
"- If `P`, then `Q`. (i.e., `P → Q`)\n"
"- If `Q`, then `R`. (i.e., `Q → R`)\n"
"\n"
"Then it logically follows that `P → R`.\n"
"\n"
"Let’s practice chaining these implications directly.\n"
"\n"
"**Note:** This level can be solved like the previous one, but it can also be done using a new tactic. Follow the hints accordingly."
msgstr ""

#: Game.Levels.Propositional.L08_ImplicationChain
msgid "The `intro` tactic assumes the premise of an implication.\n"
"\n"
"Then you can either:\n"
"- Use `apply` with a function, or\n"
"- Call implication functions directly (e.g., `exact h₂ (h₁ hp)`)."
msgstr ""

#: Game.Levels.Propositional.L08_ImplicationChain
msgid "Solves the current goal by using a function or theorem.\n"
"\n"
"If your goal is `Q` and you have `P → Q`, then `apply` turns the goal into proving `P`.\n"
"It's like saying: “To prove `Q`, it's enough to prove `P`.”"
msgstr ""

#: Game.Levels.Propositional.L08_ImplicationChain
msgid "From `P → Q` and `Q → R`, derive `P → R`."
msgstr ""

#: Game.Levels.Propositional.L08_ImplicationChain
msgid "Start with `intro` to assume that `P` is true."
msgstr ""

#: Game.Levels.Propositional.L08_ImplicationChain
msgid "Now finish the level off using `«{h₁}»` and `«{h₂}»`. Make use of apply and exact."
msgstr ""

#: Game.Levels.Propositional.L08_ImplicationChain
msgid "Perfect! You directly chained together `P → Q → R` into `P → R`."
msgstr ""

#: Game.Levels.Propositional.L09_ModusPonens
msgid "Modus Ponens"
msgstr ""

#: Game.Levels.Propositional.L09_ModusPonens
msgid "From `P → Q` and `P`, we can conclude `Q`.\n"
"\n"
"This rule of inference is known as **Modus Ponens**. Let’s practice using `apply`.\n"
"\n"
"After completing Level 7 and 8, this should be cake walk!"
msgstr ""

#: Game.Levels.Propositional.L09_ModusPonens
msgid "Solves the current goal by using a function or implication.\n"
"\n"
"If your goal is `Q` and you have `h : P → Q`, then `apply h` turns the goal into proving `P`.\n"
"\n"
"It’s like saying: “To prove `Q`, it’s enough to prove `P`.”"
msgstr ""

#: Game.Levels.Propositional.L09_ModusPonens
msgid "Modus Ponens: from `P → Q` and `P`, conclude `Q`."
msgstr ""

#: Game.Levels.Propositional.L09_ModusPonens
msgid "Use the `apply` tactic with the implication `«{h₁}»` to reduce the goal `Q` to `P`."
msgstr ""

#: Game.Levels.Propositional.L09_ModusPonens
msgid "Now you have a new goal `P`, and `«{h₂}» : P` is already available."
msgstr ""

#: Game.Levels.Propositional.L09_ModusPonens
msgid "Classic and powerful — you’ve just used **Modus Ponens** correctly."
msgstr ""

#: Game.Levels.Propositional.L10_NegationIntroduction
msgid "Negation Introduction"
msgstr ""

#: Game.Levels.Propositional.L10_NegationIntroduction
msgid "To prove `¬P`, assume `P` and derive a contradiction.\n"
"\n"
"This is called *proof by contradiction*."
msgstr ""

#: Game.Levels.Propositional.L10_NegationIntroduction
msgid "To prove `¬P`, use `intro h` to assume `P`.\n"
"\n"
"Then derive a contradiction (such as `False`), and use `exact` or `contradiction` to finish."
msgstr ""

#: Game.Levels.Propositional.L10_NegationIntroduction
msgid "If `P` leads to a contradiction, then `¬P`."
msgstr ""

#: Game.Levels.Propositional.L10_NegationIntroduction
msgid "To prove `¬P`, use `intro` to assume `P` is true."
msgstr ""

#: Game.Levels.Propositional.L10_NegationIntroduction
msgid "Now you have `«{hp}» : P`, and `«{h}» : P → False`. Apply `«{h}»` to get a contradiction."
msgstr ""

#: Game.Levels.Propositional.L10_NegationIntroduction
msgid "You’ve introduced negation: `¬P` is proven by making use of `P` itself. A bit absurd, but that's what make Math so special!"
msgstr ""

#: Game.Levels.Propositional.L11_ModusTollens
msgid "Modus Tollens"
msgstr ""

#: Game.Levels.Propositional.L11_ModusTollens
msgid "Suppose:\n"
"\n"
"- If `P` is true, then `Q` is true. (`P → Q`)\n"
"- But actually, `Q` is false. (`¬Q`)\n"
"\n"
"Then `P` must also be false. This is known as **Modus Tollens**."
msgstr ""

#: Game.Levels.Propositional.L11_ModusTollens
msgid "Use `intro` to assume `P` and then apply the implication `P → Q`.\n"
"\n"
"Finish by applying the negation `¬Q` to get a contradiction and conclude `¬P`."
msgstr ""

#: Game.Levels.Propositional.L11_ModusTollens
msgid "Modus Tollens: from `P → Q` and `¬Q`, conclude `¬P`."
msgstr ""

#: Game.Levels.Propositional.L11_ModusTollens
msgid "Use `intro` to assume `P` is true."
msgstr ""

#: Game.Levels.Propositional.L11_ModusTollens
msgid "Now finish the level off using `«{h₁}»` and `«{h₂}»` to derive a contradiction."
msgstr ""

#: Game.Levels.Propositional.L11_ModusTollens
msgid "Well done! You've applied **Modus Tollens** to conclude that `P` must be false since `Q` is false."
msgstr ""

#: Game.Levels.Propositional.L12_Contrapositive
msgid "Contrapositive"
msgstr ""

#: Game.Levels.Propositional.L12_Contrapositive
msgid "The **contrapositive** of an implication `P → Q` is `¬Q → ¬P`.\n"
"\n"
"In fact, both are logically equivalent!"
msgstr ""

#: Game.Levels.Propositional.L12_Contrapositive
msgid "You’ll use `intro`, apply implications, and reason using negation and contradiction."
msgstr ""

#: Game.Levels.Propositional.L12_Contrapositive
msgid "From `P → Q`, derive `¬Q → ¬P`."
msgstr ""

#: Game.Levels.Propositional.L12_Contrapositive
msgid "To prove `¬Q → ¬P`, use `intro` twice."
msgstr ""

#: Game.Levels.Propositional.L12_Contrapositive
msgid "Use `«{h}»` to derive `Q` from `P`, then contradict `«{hnq}»`."
msgstr ""

#: Game.Levels.Propositional.L12_Contrapositive
msgid "You’ve shown that an implication and its contrapositive are logically equivalent!"
msgstr ""

#: Game.Levels.Propositional.L13_DisjunctiveSyllogism
msgid "Disjunctive Syllogism"
msgstr ""

#: Game.Levels.Propositional.L13_DisjunctiveSyllogism
msgid "Suppose:\n"
"\n"
"- `P ∨ Q` is true (at least one must hold), and\n"
"- `P` is false (i.e., `¬P` is true)\n"
"\n"
"Then we can conclude that `Q` must be true.\n"
"\n"
"This form of inference is called **Disjunctive Syllogism**."
msgstr ""

#: Game.Levels.Propositional.L13_DisjunctiveSyllogism
msgid "The `cases` tactic lets you do case analysis on a disjunction (`P ∨ Q`).\n"
"\n"
"It splits the proof into two branches:\n"
"- one where `P` holds\n"
"- one where `Q` holds\n"
"\n"
"If one branch leads to a contradiction, use `False.elim` to derive your goal."
msgstr ""

#: Game.Levels.Propositional.L13_DisjunctiveSyllogism
msgid "If you ever reach a contradiction (`False`), you can use the `False.elim` tactic to prove **any** goal.\n"
"\n"
"This is based on the logical principle that \"from falsehood, anything follows\" (ex falso quodlibet)."
msgstr ""

#: Game.Levels.Propositional.L13_DisjunctiveSyllogism
msgid "From `P ∨ Q` and `¬P`, conclude `Q`."
msgstr ""

#: Game.Levels.Propositional.L13_DisjunctiveSyllogism
msgid "Use `cases` on `«{h}»` to handle both possibilities: `P` or `Q`."
msgstr ""

#: Game.Levels.Propositional.L13_DisjunctiveSyllogism
msgid "You now have `P`, but `«{hnp}»` says `¬P`. Apply `hnp` to get a contradiction."
msgstr ""

#: Game.Levels.Propositional.L13_DisjunctiveSyllogism
msgid "`hnp` is a function from `P → False`, and you have `P` as `h₁`. Use `exact h₁` to supply the input."
msgstr ""

#: Game.Levels.Propositional.L13_DisjunctiveSyllogism
msgid "`Q` holds directly here. Use `exact` to finish the proof."
msgstr ""

#: Game.Levels.Propositional.L13_DisjunctiveSyllogism
msgid "Nicely done! You've applied **Disjunctive Syllogism** — eliminating one side of a disjunction using negation."
msgstr ""

#: Game.Levels.Propositional.L14_DoubleNegation
msgid "Implication Application"
msgstr ""

#: Game.Levels.Propositional.L14_DoubleNegation
msgid "This level introduces the idea that an implication `P → Q` is just like a function:\n"
"if you know `P`, and you have a way to go from `P` to `Q`, then you can apply it.\n"
"\n"
"In Lean, this means using `exact h hp`, where `h : P → Q` and `hp : P`.\n"
"\n"
"Simple and satisfying!"
msgstr ""

#: Game.Levels.Propositional.L14_DoubleNegation
msgid "If `P → Q` and `P` both hold, then `Q` must also hold. An extension of Modus Ponens"
msgstr ""

#: Game.Levels.Propositional.L14_DoubleNegation
msgid "`h` is a function from `P` to `Q`, and `hp` gives you `P`. Just apply the function!"
msgstr ""

#: Game.Levels.Propositional.L14_DoubleNegation
msgid "Nice! You just applied a function — that's really all an implication is.\n"
"\n"
"`P → Q` is the same as saying: “If I have `P`, I can give you `Q`.”\n"
"\n"
"You’ll see this pattern come up a lot in proofs."
msgstr ""

#: Game.Levels.Propositional.L15_Dilemma
msgid "Dilemma"
msgstr ""

#: Game.Levels.Propositional.L15_Dilemma
msgid "This is the **Constructive Dilemma**:\n"
"\n"
"From `P ∨ Q`, `P → R`, and `Q → R`, you can conclude `R`.\n"
"\n"
"It's case-based reasoning again."
msgstr ""

#: Game.Levels.Propositional.L15_Dilemma
msgid "Use `cases` on the disjunction `P ∨ Q`, then use `apply` or `exact` in each branch with the given implications."
msgstr ""

#: Game.Levels.Propositional.L15_Dilemma
msgid "From `P ∨ Q`, `P → R`, and `Q → R`, derive `R`."
msgstr ""

#: Game.Levels.Propositional.L15_Dilemma
msgid "Use `cases` on `«{hpq}»` to consider each possibility."
msgstr ""

#: Game.Levels.Propositional.L15_Dilemma
msgid "`P` holds. Use `«{hpr}»` to conclude `R`."
msgstr ""

#: Game.Levels.Propositional.L15_Dilemma
msgid "`Q` holds. Use `«{hqr}»` to conclude `R`."
msgstr ""

#: Game.Levels.Propositional.L15_Dilemma
msgid "Excellent! You've completed the Constructive Dilemma — a powerful inference rule using `∨`."
msgstr ""

#: Game.Levels.Propositional.Propositional
msgid "Propositional Logic"
msgstr ""

#: Game.Levels.Propositional.Propositional
msgid "In this world, you'll explore the foundations of propositional logic.\n"
"\n"
"Each level presents a new fundamental theorem or principle.\n"
"\n"
"Click on the button at the bottom left to continue."
msgstr ""

#: Game
msgid "Discrete Mathematics with Lean4"
msgstr ""

#: Game
msgid "Welcome to **Discrete Math with Lean4**, a fun and interactive game that will help you in proving several theorems **MH1812 - Discrete Mathematics**\n"
"\n"
"There are several levels that you can try out in each world. Each level essentially covers a theorem taught in the lecture. And you have many such levels queued up in a world.\n"
"Start by clicking on **Propositional** on the right."
msgstr ""

#: Game
msgid "This is the first iteration of this game. You can find the source code at [GitHub Repository – gamemaker](https://github.com/shreyvivek/gamemaker)."
msgstr ""

#: Game
msgid "MH1812"
msgstr ""

#: Game
msgid "You can use this game as a template for your own game and add your own levels, if you are keen to learn more about Lean4."
msgstr ""
