msgid ""
msgstr "Project-Id-Version: Game v4.7.0\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: Tue Jul 29 15:25:52 2025\n"
"Last-Translator: \n"
"Language-Team: none\n"
"Language: en\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit"

#: GameServer.RpcHandlers
msgid "level completed! üéâ"
msgstr ""

#: GameServer.RpcHandlers
msgid "level completed with warnings‚Ä¶ üé≠"
msgstr ""

#: GameServer.RpcHandlers
msgid "intermediate goal solved! üéâ"
msgstr ""

#: Game.Levels.Propositional.L01_AssumeAndFinish
msgid "Assume and Finish"
msgstr ""

#: Game.Levels.Propositional.L01_AssumeAndFinish
msgid "Welcome!\n"
"\n"
"Let‚Äôs begin with the simplest task. Let `P` be a proposition.\n"
"\n"
"```\n"
"P: It is raining.\n"
"```\n"
"If you're told `P` is true, then you can conclude `P`.\n"
"That's like - you already know it is raining. So you can also make the conclusion, that it is raining.\n"
"\n"
"Sounds trivial, but this teaches you how to use assumptions to finish a goal."
msgstr ""

#: Game.Levels.Propositional.L01_AssumeAndFinish
msgid "Purpose: Use exact when you already have a proof of exactly what the goal is asking for.\n"
"\n"
"It closes the goal immediately if the term matches the goal‚Äôs type.\n"
"\n"
"üìå Think of it as:\n"
"\n"
"‚ÄúHere's exactly what you're asking for ‚Äî done!‚Äù\n"
"\n"
"---\n"
"\n"
"### In Propositional Logic:\n"
"\n"
"If your goal is `P` and you have a proof of `P` (say `h : P`), then `exact h` completes the proof.\n"
"\n"
"To summarize:\n"
"\n"
"You have : `h : P`\n"
"Your goal : `P`\n"
"`exact h` will complete the proof!\n"
"\n"
"---\n"
"\n"
"### In Sets:\n"
"\n"
"You‚Äôre given:\n"
"\n"
"- A set `A : Set ‚Ñï`\n"
"- An element `x : ‚Ñï`\n"
"- A hypothesis `h : x ‚àà A`\n"
"\n"
"And your goal is to prove exactly that: `x ‚àà A`.\n"
"\n"
"Since your goal *already matches* your assumption, just use:\n"
"\n"
"`exact h`\n"
"\n"
"This is the most basic kind of step in a proof: confirming something you‚Äôve already assumed.\n"
"\n"
"---"
msgstr ""

#: Game.Levels.Propositional.L01_AssumeAndFinish
msgid "### Logic Constants & Operators\n"
"\n"
"|Name       | Symbol | Commands                          |\n"
"|-----------|--------|-----------------------------------|\n"
"|Not        | ¬¨      | `\\n`, `\\not`, `\\neg`, `\\lnot`     |\n"
"|And        | ‚àß      | `\\and`, `\\an`, `\\wedge`           |\n"
"|Or         | ‚à®      | `\\v`, `\\or`, `\\vee`               |\n"
"|Implies    | ‚Üí      | `\\r`, `\\imp`, `\\to`               |\n"
"|Iff        | ‚Üî      | `\\iff`, `\\lr`                     |\n"
"|For All    | ‚àÄ      | `\\all`, `\\forall`                 |\n"
"|Exists     | ‚àÉ      | `\\ex`, `\\exists`                  |\n"
"|Belongs    | ‚àà      | `\\in`                             |\n"
"|Subset     | ‚äÜ      | `\\subset`                         |\n"
"|Union      | ‚à™      | `\\union`, `\\un`                   |\n"
"|Intersect  | ‚à©      | `\\intersect`, `\\cap`              |\n"
"|Pair-Left  | ‚ü®       | `\\<`                             |\n"
"|Pair-Right | ‚ü©       | `\\>`                             |"
msgstr ""

#: Game.Levels.Propositional.L01_AssumeAndFinish
msgid "Use the `exact` tactic with `¬´{h}¬ª` to directly prove the goal `P`. Type `exact h`.\n"
"\n"
"Note: You need to click `Retry` whenever you encounter an error at any step. Be sure to click that particular `Retry` where the error pops up."
msgstr ""

#: Game.Levels.Propositional.L01_AssumeAndFinish
msgid "You‚Äôve completed your first proof ‚Äî and yes, it really was that simple!"
msgstr ""

#: Game.Levels.Propositional.L02_IntroduceAssumption
msgid "Introduce Assumption"
msgstr ""

#: Game.Levels.Propositional.L02_IntroduceAssumption
msgid "Let‚Äôs prove an implication: `P ‚Üí P`. That is, if `P` holds, then `P` holds (trivially).\n"
"\n"
"This level introduces the `intro` tactic."
msgstr ""

#: Game.Levels.Propositional.L02_IntroduceAssumption
msgid "Purpose: Use intro to assume something ‚Äî usually when proving an implication.\n"
"\n"
"If your goal is `P ‚Üí Q`, `intro h` changes the goal to `Q` and gives you `h : P` as a local assumption.\n"
"\n"
"üìå Think of it as:\n"
"\n"
"‚ÄúLet me assume `P` is true for now, and see if I can prove `Q`.‚Äù\n"
"Opens up an implication goal by introducing its assumption.\n"
"\n"
"---\n"
"\n"
"### In Propositional Logic:\n"
"\n"
"Your goal : `h : P ‚Üí P`\n"
"After `intro h`,\n"
"you get an assumption `h : P` and your goal will just be `P`.\n"
"\n"
"---\n"
"\n"
"### In Sets:\n"
"\n"
"You‚Äôre given:\n"
"- A set `A : Set ‚Ñï`\n"
"\n"
"To prove `A ‚äÜ A`, you must show: `‚àÄ x, x ‚àà A ‚Üí x ‚àà A`\n"
"\n"
"Strategy:\n"
"1. Use `intro x` to assume an arbitrary element.\n"
"2. Use `intro h` to assume `x ‚àà A`.\n"
"3. Use `exact h` to conclude `x ‚àà A`.\n"
"\n"
"This pattern is the **structure of proving subset relations**.\n"
"\n"
"---"
msgstr ""

#: Game.Levels.Propositional.L02_IntroduceAssumption
msgid "Use the `intro` tactic to assume `P` is true. Try `intro h`."
msgstr ""

#: Game.Levels.Propositional.L02_IntroduceAssumption
msgid "Now you have `¬´{h}¬ª : P`, and your goal is `P`. Use `exact` to finish."
msgstr ""

#: Game.Levels.Propositional.L02_IntroduceAssumption
msgid "That was a basic implication! The `intro` tactic is your go-to tool for these."
msgstr ""

#: Game.Levels.Propositional.L03_AndIntroduction
msgid "And Introduction"
msgstr ""

#: Game.Levels.Propositional.L03_AndIntroduction
msgid "From `P` and `Q`, we can conclude `P ‚àß Q`. That‚Äôs how conjunction works!\n"
"\n"
"You‚Äôll learn the `constructor` tactic in this level."
msgstr ""

#: Game.Levels.Propositional.L03_AndIntroduction
msgid "Purpose: Use constructor when your goal is a conjunction (`P ‚àß Q`).\n"
"\n"
"It splits the goal into two subgoals: one for `P`, and one for `Q`.\n"
"\n"
"üìå Think of it as:\n"
"\n"
"‚ÄúTo prove both `P` and `Q`, let‚Äôs do them one at a time.‚Äù\n"
"\n"
"---\n"
"\n"
"### In Propositional Logic:\n"
"\n"
"`constructor` on `P ‚àß Q` gives you two sub goals ‚Äî one for `P` and one for `Q`.\n"
"\n"
"---\n"
"\n"
"### In Sets:\n"
"\n"
"If your goal is `x ‚àà A ‚à© B`, use `constructor` and then prove `x ‚àà A` and `x ‚àà B` separately.\n"
"\n"
"---"
msgstr ""

#: Game.Levels.Propositional.L03_AndIntroduction
msgid "Use the `constructor` tactic to split the goal `P ‚àß Q` into two parts."
msgstr ""

#: Game.Levels.Propositional.L03_AndIntroduction
msgid "Firstly, prove `P` using `¬´{hp}¬ª` in the `Active Goal` to proceed to `Goal 2`\n"
"\n"
"Then, in `Goal 2`, prove `Q` using `¬´{hq}¬ª`."
msgstr ""

#: Game.Levels.Propositional.L03_AndIntroduction
msgid "Nice work! You combined two truths into one solid conjunction."
msgstr ""

#: Game.Levels.Propositional.L04_AndEliminationLeft
msgid "And Elimination (Left)"
msgstr ""

#: Game.Levels.Propositional.L04_AndEliminationLeft
msgid "If you know `P ‚àß Q`, then you can extract `P` from it.\n"
"\n"
"We‚Äôll use the `exact` tactic, combined with `.left`, described further below."
msgstr ""

#: Game.Levels.Propositional.L04_AndEliminationLeft
msgid "As you know, the `exact` tactic finishes the goal using a term that exactly matches the target.\n"
"\n"
"If you have `h : P ‚àß Q`, then:\n"
"- `h.left` gives you a term of type `P`\n"
"- `h.right` gives you a term of type `Q`\n"
"\n"
"These are not tactics, but useful expressions to pass to `exact`.\n"
"\n"
"Now you know what to do to extract the left part `P` from `P ‚àß Q` using `exact`."
msgstr ""

#: Game.Levels.Propositional.L04_AndEliminationLeft
msgid "Nicely done! You extracted the left side of a conjunction. A similar procedure can be followed to extract the right half of a conjunction."
msgstr ""

#: Game.Levels.Propositional.L05_OrIntroductionLeft
msgid "Or Introduction (Left)"
msgstr ""

#: Game.Levels.Propositional.L05_OrIntroductionLeft
msgid "Let‚Äôs now turn to disjunctions ‚Äî statements involving the word 'or'.\n"
"\n"
"In Lean, `P ‚à® Q` means ‚Äúeither `P` is true, or `Q` is true (or both).‚Äù\n"
"To prove something like `P ‚à® Q`, it‚Äôs enough to prove just one side ‚Äî because *at least one must be true*.\n"
"\n"
"In this level, you already have a proof of `P`, and your goal is `P ‚à® Q`.\n"
"So all you have to do is tell Lean: ‚ÄúI want to prove the left side of the disjunction‚Äù, as you can finish it off with your existing proof."
msgstr ""

#: Game.Levels.Propositional.L05_OrIntroductionLeft
msgid "Purpose: Use `left` when your goal is a disjunction (`P ‚à® Q`) and you want to prove the **left** part.\n"
"\n"
"If your goal is `P ‚à® Q`, then `left` changes the goal to proving `P`.\n"
"\n"
"üìå Think of it as:\n"
"\n"
"‚ÄúI‚Äôll prove the first part of the `or`, and that‚Äôs good enough.‚Äù\n"
"\n"
"---\n"
"\n"
"### In Propositional Logic:\n"
"\n"
"Your goal : `P ‚à® Q`\n"
"\n"
"After `left`, your new goal is just `P`.\n"
"\n"
"---\n"
"\n"
"### In Sets:\n"
"\n"
"Your goal : `x ‚àà A ‚à™ B`\n"
"\n"
"After `left`, your new goal is just `x ‚àà A`.\n"
"\n"
"---"
msgstr ""

#: Game.Levels.Propositional.L05_OrIntroductionLeft
msgid "Use the `left` tactic to say `P ‚à® Q` is true because `P` is true.\n"
"\n"
"**Note:** Here you are directly operating on the goal itself. So you just need to type `left` and Lean will understand."
msgstr ""

#: Game.Levels.Propositional.L05_OrIntroductionLeft
msgid "Now you can finish the level yourself."
msgstr ""

#: Game.Levels.Propositional.L05_OrIntroductionLeft
msgid "Great! You‚Äôve learned how to state that ‚Äúat least one is true.‚Äù"
msgstr ""

#: Game.Levels.Propositional.L06_OrIntroductionRight
msgid "Or Introduction (Right)"
msgstr ""

#: Game.Levels.Propositional.L06_OrIntroductionRight
msgid "If `Q` is true, then `P ‚à® Q` is also true ‚Äî because *at least one* must hold.\n"
"\n"
"Now let‚Äôs learn how to use the `right` tactic."
msgstr ""

#: Game.Levels.Propositional.L06_OrIntroductionRight
msgid "Purpose: Use `right` when your goal is a disjunction (`P ‚à® Q`) and you want to prove the **right** part.\n"
"\n"
"If your goal is `P ‚à® Q`, then `right` changes the goal to proving `Q`.\n"
"\n"
"üìå Think of it as:\n"
"\n"
"‚ÄúI‚Äôll prove the second part of the `or`, and that‚Äôs good enough.‚Äù\n"
"\n"
"---\n"
"\n"
"### In Propositional Logic:\n"
"\n"
"Your goal : `P ‚à® Q`\n"
"\n"
"After `right`, your new goal is just `Q`.\n"
"\n"
"---\n"
"\n"
"### In Sets:\n"
"\n"
"Your goal : `x ‚àà A ‚à™ B`\n"
"\n"
"After `right`, your new goal is just `x ‚àà B`.\n"
"\n"
"---"
msgstr ""

#: Game.Levels.Propositional.L06_OrIntroductionRight
msgid "Use the `right` tactic this time, to commit to proving `Q` instead of `P`."
msgstr ""

#: Game.Levels.Propositional.L06_OrIntroductionRight
msgid "Now you can finish the level yourself."
msgstr ""

#: Game.Levels.Propositional.L06_OrIntroductionRight
msgid "Great! You've now mastered both `left` and `right` tactics, and how they can be useful in a disjunction."
msgstr ""

#: Game.Levels.Propositional.L07_ModusPonens
msgid "Modus Ponens"
msgstr ""

#: Game.Levels.Propositional.L07_ModusPonens
msgid "Time to visit one of the most fundamental rules of inference: **Modus Ponens**.\n"
"\n"
"It says:\n"
"> If `P ‚Üí Q` and `P` are both true, then `Q` must also be true.\n"
"\n"
"In Lean, this means:\n"
"- If you have `implication : P ‚Üí Q`, and\n"
"- `fact : P`,\n"
"\n"
"then you can apply the implication to the fact to get `Q`.\n"
"\n"
"This is what we‚Äôll do in this level:\n"
"You‚Äôre given `P ‚Üí Q` and `P`, and your goal is to prove `Q`.\n"
"\n"
"You're going to make use of `apply` tactic.\n"
"Let‚Äôs break it down step by step."
msgstr ""

#: Game.Levels.Propositional.L07_ModusPonens
msgid "Purpose: Use `apply` to reduce your current goal to an earlier implication.\n"
"\n"
"If your goal is `Q`, and you have `implication : P ‚Üí Q`,\n"
"then `apply implication` changes the goal to `P`.\n"
"\n"
"üìå Think of it as:\n"
"\n"
"‚ÄúTo prove `Q`, it‚Äôs enough to prove `P` ‚Äî because I already have `P ‚Üí Q`.‚Äù\n"
"\n"
"---"
msgstr ""

#: Game.Levels.Propositional.L07_ModusPonens
msgid "Modus Ponens: from `P ‚Üí Q` and `P`, conclude `Q`."
msgstr ""

#: Game.Levels.Propositional.L07_ModusPonens
msgid "Your goal is `Q`, and you have an implication `h‚ÇÅ : P ‚Üí Q`.\n"
"\n"
"By writing `apply h‚ÇÅ`, you are telling Lean:\n"
"‚ÄúTo prove `Q`, it suffices to prove `P`.‚Äù\n"
"\n"
"That‚Äôs because `P ‚Üí Q` works like a function:\n"
"If you give it `P`, it will return `Q`.\n"
"\n"
"So `apply h‚ÇÅ` transforms your goal from `Q` to `P`,\n"
"and Lean now expects you to prove `P`.\n"
"\n"
"Now go ahead ‚Äî apply the implication!\n"
"\n"
"_for writing subscript 1, type `h`, enter a backslash and then enter `1`._"
msgstr ""

#: Game.Levels.Propositional.L07_ModusPonens
msgid "Now the goal has changed to `P`. You're being asked to prove the condition of the implication.\n"
"\n"
"Luckily, you already have `h‚ÇÇ : P`. Use `exact` to finish!"
msgstr ""

#: Game.Levels.Propositional.L07_ModusPonens
msgid "Nicely done! You‚Äôve applied **Modus Ponens** by thinking backwards from your goal.\n"
"\n"
"You told Lean: ‚ÄúTo prove `Q`, I‚Äôll use `P ‚Üí Q`, so just give me `P`.‚Äù\n"
"\n"
"That‚Äôs the core idea behind the `apply` tactic ‚Äî a major tool in your proof toolkit."
msgstr ""

#: Game.Levels.Propositional.L08_OrElimination
msgid "Or Elimination"
msgstr ""

#: Game.Levels.Propositional.L08_OrElimination
msgid "You might remember one such proof from lectures ‚Äî **Dilemma**."
msgstr ""

#: Game.Levels.Propositional.L08_OrElimination
msgid "Purpose: Use `cases` on a disjunction (e.g. `P ‚à® Q`) to split it into two separate cases.\n"
"\n"
"Each case creates a new assumption:\n"
"- `inl hp` means `P` is assumed true\n"
"- `inr hq` means `Q` is assumed true\n"
"\n"
"üìå Think of it as:\n"
"\n"
"‚ÄúLet‚Äôs examine both possible scenarios and show that the goal works either way.‚Äù\n"
"\n"
"---\n"
"\n"
"### In Propositional Logic:\n"
"\n"
"Given: `h : P ‚à® Q`\n"
"\n"
"After `cases h`:\n"
"- Case 1: `hp : P`\n"
"- Case 2: `hq : Q`\n"
"\n"
"---\n"
"\n"
"### In Sets:\n"
"\n"
"Suppose:\n"
"\n"
"`h : x ‚àà A ‚à™ B` (i.e., `x ‚àà A ‚à® x ‚àà B`)\n"
"\n"
"Then:\n"
"\n"
"After `cases h`:\n"
"- Case 1: `ha : x ‚àà A`\n"
"- Case 2: `hb : x ‚àà B`\n"
"\n"
"---"
msgstr ""

#: Game.Levels.Propositional.L08_OrElimination
msgid "---\n"
"\n"
"**Given:**\n"
"- (1) `P ‚à® Q`\n"
"- (2) `P ‚Üí R`\n"
"- (3) `Q ‚Üí R`\n"
"\n"
"**To Prove:** `R`\n"
"\n"
"---\n"
"\n"
"**Proof (in natural language):**\n"
"\n"
"We use disjunction elimination on `P ‚à® Q`, i.e., we consider both cases separately:\n"
"\n"
"---\n"
"\n"
"- *Case 1:* Assume `P` is true.\n"
"\n"
"From (2), `P ‚Üí R`, so `R` is true (Modus Ponens).\n"
"\n"
"- *Case 2:* Assume `Q` is true.\n"
"\n"
"From (3), `Q ‚Üí R`, so again `R` is true (Modus Ponens).\n"
"\n"
"---\n"
"\n"
"In both cases, `R` is true.\n"
"\n"
"So regardless of whether `P` or `Q` is true, we conclude:\n"
"\n"
"**`R` is true.**\n"
"\n"
"\n"
"Let us now try it in Lean. Also, `modus_ponens` as a `Theorem` is now unlocked under `Theorems` and can be found under the `Propositional` section."
msgstr ""

#: Game.Levels.Propositional.L08_OrElimination
msgid "Use the `cases` tactic to break the disjunction `hpq` into two cases: one - the `Active Goal` where `P` is true, and `Goal 2` - where `Q` is true."
msgstr ""

#: Game.Levels.Propositional.L08_OrElimination
msgid "In this case, `P` holds (`h : P`) and you also have `hpr : P ‚Üí R`.\n"
"\n"
"This matches the **Modus Ponens** pattern: if `P` is true and `P ‚Üí R`, then `R` must be true.\n"
"\n"
"Use the `exact` tactic to apply the implication, with `modus_ponens` like this : `exact modus_ponens hpr h`.\n"
"\n"
"This tells Lean to use modus_ponens on `hpr` and `h‚ÇÅ`, resulting in `R`.\n"
"\n"
"Do similarly for when `Q` is assumed to be true in `Goal 2`."
msgstr ""

#: Game.Levels.Propositional.L08_OrElimination
msgid "You‚Äôve completed a textbook disjunction elimination! You can also see how versatile the `exact` tactic is.\n"
"\n"
"By showing the goal holds in **both** branches of the `or`, you‚Äôve logically proven it no matter what."
msgstr ""

#: Game.Levels.Propositional.L09_ImplicationChain
msgid "Implication Chain"
msgstr ""

#: Game.Levels.Propositional.L09_ImplicationChain
msgid "You‚Äôre given two facts:\n"
"\n"
"1. If `P` is true, then `Q` is true. (`P ‚Üí Q`)\n"
"2. If `Q` is true, then `R` is true. (`Q ‚Üí R`)\n"
"\n"
"Your task: prove that `P` implies `R` ‚Äî in other words, show that `P ‚Üí R`.\n"
"\n"
"This is called **chaining implications**. It‚Äôs a very common pattern in logic and proofs.\n"
"\n"
"The idea is:\n"
"‚ÄúIf `P` gives me `Q`, and `Q` gives me `R`, then `P` gives me `R`.‚Äù\n"
"\n"
"In this level, you‚Äôll:\n"
"- assume `P` is true,\n"
"- use it to get `Q` via the first implication,\n"
"- and then use that `Q` to get `R` via the second implication.\n"
"\n"
"You‚Äôll learn how to use the `have` tactic to break up and name intermediate steps ‚Äî a powerful tool for writing clean, readable proofs.\n"
"\n"
"_**Note:** There can be many alternative ways to prove the same level, with tactics you may already know. If you are keen, try them out! PS: You will not be prompted with hints in that case :)_"
msgstr ""

#: Game.Levels.Propositional.L09_ImplicationChain
msgid "Purpose: Use `have` to create and name an intermediate result in your proof.\n"
"\n"
"It lets you:\n"
"- Break up long reasoning chains\n"
"- Improve clarity and structure\n"
"- Reuse partial results later\n"
"\n"
"---\n"
"\n"
"### In Propositional Logic:\n"
"\n"
"If you have `h‚ÇÅ : P ‚Üí Q` and `hp : P`, and you want to reach `Q`, you can write:\n"
"\n"
"`have hq : Q := modus_ponens h‚ÇÅ hp`.\n"
"\n"
"Similar to what\n"
"\n"
"`exact modus_ponens h‚ÇÅ hp` would do.\n"
"\n"
"---\n"
"\n"
"### In Sets:\n"
"\n"
"If you have:\n"
"\n"
"h‚ÇÅ : A ‚äÜ B (which is a function: x ‚àà A ‚Üí x ‚àà B)\n"
"\n"
"h : x ‚àà A\n"
"\n"
"Then you can write:\n"
"\n"
"`have xb : x ‚àà B := h‚ÇÅ x h`\n"
"Now `xb` stores `x ‚àà B` for later use.\n"
"\n"
"This tactic is useful when proofs grow longer or when you want to give names to intermediate steps to reason about them clearly.\n"
"\n"
"---"
msgstr ""

#: Game.Levels.Propositional.L09_ImplicationChain
msgid "Quite obvious, you can start with `intro`."
msgstr ""

#: Game.Levels.Propositional.L09_ImplicationChain
msgid "One way to go ahead is to use the exact statement by writing something like `exact modus_ponens h‚ÇÇ (modus_ponens h‚ÇÅ a)`\n"
"\n"
"Looks complicated, and I hope you aren't too confused, because there's an amazing tactic to use here. Read about the `have` tactic on the right.\n"
"\n"
"**Note** that the `have` tactic is strict on syntax, but it simplifies your task in seconds! Also if you just write `modus_ponens h‚ÇÅ hp` in the `have` tactic, it does the same thing as `exact modus_ponens h‚ÇÅ hp`"
msgstr ""

#: Game.Levels.Propositional.L09_ImplicationChain
msgid "The syntax is something like `have hq : Q := modus_ponens h‚ÇÅ hp`\n"
"`have (_name you give_) : (_what you deduce_) := (_how you deduce it_)`"
msgstr ""

#: Game.Levels.Propositional.L09_ImplicationChain
msgid "Perfect! You used the have tactic to extract Q from P ‚Üí Q, and then concluded R cleanly.\n"
"\n"
"This kind of structured chaining is essential in longer proofs ‚Äî well done!"
msgstr ""

#: Game.Levels.Propositional.L10_NegationIntroduction
msgid "Negation Introduction"
msgstr ""

#: Game.Levels.Propositional.L10_NegationIntroduction
msgid "You‚Äôre now going to prove something of the form `¬¨P`.\n"
"\n"
"What does that mean?\n"
"\n"
"> `¬¨P` is just shorthand for `P ‚Üí False`. Why? See below:\n"
"\n"
"### Truth Table for ¬¨P and P ‚Üí False\n"
"\n"
"| P   | ¬¨P  | P ‚Üí False |\n"
"|-----|-----|-----------|\n"
"| T   | F   | F         |\n"
"| F   | T   | T         |\n"
"\n"
"So, to prove `¬¨P`, you must:\n"
"1. Assume `P`\n"
"2. Derive a contradiction (i.e., prove `False`)\n"
"3. That shows `P` can‚Äôt be true ‚Äî which proves `¬¨P`\n"
"\n"
"This is called **negation introduction** ‚Äî a foundational pattern in proof by contradiction.\n"
"\n"
"In this level, you're given:\n"
"- `h : P ‚Üí False`\n"
"And your goal is to prove `¬¨P`.\n"
"\n"
"Let‚Äôs walk through how to unpack and apply this."
msgstr ""

#: Game.Levels.Propositional.L10_NegationIntroduction
msgid "Your goal is `¬¨P`, which is just `P ‚Üí False`. Use `intro` to assume that `P` holds."
msgstr ""

#: Game.Levels.Propositional.L10_NegationIntroduction
msgid "Now your goal is to prove `False`. You have `assumed_p : P`, and a function `h : P ‚Üí False`."
msgstr ""

#: Game.Levels.Propositional.L10_NegationIntroduction
msgid "`_____ modus_ponens __ __`. By now, you should know what to fill in the blanks! Eventually, it will give you `False`."
msgstr ""

#: Game.Levels.Propositional.L10_NegationIntroduction
msgid "This shows that assuming `P` leads to `False`, which proves `¬¨P`."
msgstr ""

#: Game.Levels.Propositional.L10_NegationIntroduction
msgid "You‚Äôve introduced negation: `¬¨P` is proven by assuming `P` is true itself. Something like the proof by contradiction, whose applications you would have seen earlier in your math classes.\n"
"\n"
"There is no right or wrong method, use whatever you find more comfortable. After all, the objective of this game is to build that intuition in proving everyday statements/theorems you encounter in math."
msgstr ""

#: Game.Levels.Propositional.L11_ModusTollens
msgid "Modus Tollens"
msgstr ""

#: Game.Levels.Propositional.L11_ModusTollens
msgid "This level introduces another classic rule of inference: **Modus Tollens**.\n"
"\n"
"You may recall from Level 7 (**Modus Ponens**) that:\n"
"> If `P ‚Üí Q` and `P` are true, then `Q` is true.\n"
"Now imagine the opposite:\n"
"> If `P ‚Üí Q` and `Q` is **false**, then `P` must also be false.\n"
"\n"
"That‚Äôs **Modus Tollens**.\n"
"Let‚Äôs break it down logically:\n"
"\n"
"You‚Äôre given:\n"
"- `implication : P ‚Üí Q`\n"
"- `not_q : ¬¨Q` (i.e., `Q ‚Üí False`)\n"
"Your goal is:\n"
"- `¬¨P` (i.e., `P ‚Üí False`)\n"
"\n"
"This means:\n"
"‚ÄúAssume `P`. Then use `P ‚Üí Q` to get `Q`, and then use `¬¨Q` to show that `Q` leads to `False` ‚Äî which proves `¬¨P`.‚Äù\n"
"Notice how this structure is **very similar to Level 10 (Negation Introduction)**:\n"
"- You assume something (`P`)\n"
"- Derive a contradiction\n"
"- Conclude its negation\n"
"But here, you must **chain implications across two steps**:\n"
"`P ‚Üí Q`, then `Q ‚Üí False`, to eventually get `P ‚Üí False`.\n"
"\n"
"Let‚Äôs walk through this chain and build the logic slowly."
msgstr ""

#: Game.Levels.Propositional.L11_ModusTollens
msgid "Modus Tollens: from `P ‚Üí Q` and `¬¨Q`, conclude `¬¨P`."
msgstr ""

#: Game.Levels.Propositional.L11_ModusTollens
msgid "We are proving `¬¨P`, which means the goal is `P ‚Üí False`.\n"
"\n"
"This type is a function ‚Äî it says: ‚ÄúIf you give me a proof of `P`, I will return a contradiction.‚Äù\n"
"\n"
"To do that, **assume `P` holds**, and then try to derive a contradiction from it.\n"
"\n"
"Use the `intro` tactic to assume `P`."
msgstr ""

#: Game.Levels.Propositional.L11_ModusTollens
msgid "Now your goal has become `False`.\n"
"\n"
"Let‚Äôs see what you have:\n"
"\n"
"- `h‚ÇÇ : ¬¨Q` (this means `Q ‚Üí False`)\n"
"- `h‚ÇÅ : P ‚Üí Q`\n"
"- `hp : P`\n"
"\n"
"We want to reach a contradiction ‚Äî `False`.\n"
"\n"
"Let‚Äôs look at `h‚ÇÇ`. It says:\n"
"> ‚ÄúIf you give me `Q`, I‚Äôll give you `False`.‚Äù\n"
"\n"
"So the idea is: **try to produce `Q`, then feed it into `h‚ÇÇ`.**\n"
"\n"
"Use `apply h‚ÇÇ` to say:\n"
"> ‚ÄúTo prove `False`, it‚Äôs enough to prove `Q`.‚Äù"
msgstr ""

#: Game.Levels.Propositional.L11_ModusTollens
msgid "Now your goal is to prove `Q`.\n"
"\n"
"How can we get `Q`?\n"
"\n"
"You have:\n"
"- `h‚ÇÅ : P ‚Üí Q`\n"
"- `hp : P`\n"
"\n"
"So this is a perfect match for applying an implication.\n"
"\n"
"Use `apply h‚ÇÅ` to transform your goal from `Q` to `P`."
msgstr ""

#: Game.Levels.Propositional.L11_ModusTollens
msgid "Now your goal is `P`.\n"
"\n"
"But you already assumed `P` at the very beginning, as `hp`.\n"
"\n"
"So simply use:\n"
"`exact hp`\n"
"\n"
"to conclude the proof.\n"
"\n"
"If you find this whole proof to be weird, just go with `have` and `exact` everywhere, step by step."
msgstr ""

#: Game.Levels.Propositional.L11_ModusTollens
msgid "Well done! You‚Äôve just used **Modus Tollens** with a clean chain of `apply` steps.\n"
"\n"
"This level showed how `apply` works **in reverse**:\n"
"- From `False`, you worked backwards through `Q ‚Üí False` and `P ‚Üí Q` to reduce everything to `P`, which you already had.\n"
"\n"
"This step-by-step approach gives you precise control over each part of the logic."
msgstr ""

#: Game.Levels.Propositional.L12_Contrapositive
msgid "Contrapositive"
msgstr ""

#: Game.Levels.Propositional.L12_Contrapositive
msgid "You may remember that every implication `P ‚Üí Q`\n"
"is **logically equivalent** to its contrapositive: `¬¨Q ‚Üí ¬¨P`.\n"
"\n"
"This means:\n"
"> If `P ‚Üí Q`, then `¬¨Q ‚Üí ¬¨P` is also true.\n"
"\n"
"You‚Äôve already seen this idea in Level 11 (Modus Tollens):\n"
"- If `P ‚Üí Q` and `Q` is false, then `P` must be false.\n"
"\n"
"In this level, you‚Äôre going to prove the general version:\n"
"Given only `P ‚Üí Q`, show that `¬¨Q ‚Üí ¬¨P`.\n"
"\n"
"Let‚Äôs unpack this step by step."
msgstr ""

#: Game.Levels.Propositional.L12_Contrapositive
msgid "To prove `¬¨Q ‚Üí ¬¨P`, first recognize that it's shorthand for `(Q ‚Üí False) ‚Üí (P ‚Üí False)`."
msgstr ""

#: Game.Levels.Propositional.L12_Contrapositive
msgid "That means this is a **nested implication**, so we‚Äôll need to assume both `¬¨Q` and `P` before we can prove `False`. Do `intro not_q`"
msgstr ""

#: Game.Levels.Propositional.L12_Contrapositive
msgid "`not_q` now holds: you‚Äôre assuming `Q ‚Üí False`. Now to prove `¬¨P`, we must show `P ‚Üí False` ‚Äî so assume `P` next via `intro assumed_p`."
msgstr ""

#: Game.Levels.Propositional.L12_Contrapositive
msgid "Your goal is now `False`. Think: how do you reach a contradiction from `P`?"
msgstr ""

#: Game.Levels.Propositional.L12_Contrapositive
msgid "You have `h : P ‚Üí Q`, and you also assumed `P` as `assumed_p`. So, from those two, you can get `Q`."
msgstr ""

#: Game.Levels.Propositional.L12_Contrapositive
msgid "But your goal is `False`, and you have `not_q : Q ‚Üí False`. This gives you a strategy: `apply not_q` will change the goal to a proof of `Q`."
msgstr ""

#: Game.Levels.Propositional.L12_Contrapositive
msgid "You now need to prove `Q`, and you have `h : P ‚Üí Q` and `assumed_p : P`. This is a perfect setup for `apply` again, but this time, with `h`."
msgstr ""

#: Game.Levels.Propositional.L12_Contrapositive
msgid "Now the goal is `P`, and you already have `assumed_p : P`. Use `exact assumed_p` to finish."
msgstr ""

#: Game.Levels.Propositional.L12_Contrapositive
msgid "Awesome! You've just proven the **contrapositive** form of an implication ‚Äî an essential logical equivalence.\n"
"\n"
"Though this level was heavy on hints, it brought together everything you‚Äôve learned:\n"
"- You used `intro` to build nested assumptions\n"
"- You used `apply` to break apart implications\n"
"- And you combined all the pieces to reach a contradiction\n"
"\n"
"This is real formal logic ‚Äî and you're solving it in Lean."
msgstr ""

#: Game.Levels.Propositional.L13_DisjunctiveSyllogism
msgid "Disjunctive Syllogism"
msgstr ""

#: Game.Levels.Propositional.L13_DisjunctiveSyllogism
msgid "In this level, you‚Äôll prove a very common logical inference called **Disjunctive Syllogism**.\n"
"\n"
"It works like this:\n"
"\n"
"> If `P ‚à® Q` is true, and `P` is false, then `Q` must be true.\n"
"\n"
"This makes sense ‚Äî `P ‚à® Q` tells us that at least one of them is true.\n"
"If we know that `P` is *not* true (`¬¨P`), then `Q` is the only possibility left.\n"
"\n"
"You will combine a lot of lessons from previous levels to clear this one.\n"
"You will also make use of another theorem to achieve this. Read about `False.elim` on the Theorems section!"
msgstr ""

#: Game.Levels.Propositional.L13_DisjunctiveSyllogism
msgid "`False.elim` ‚Äî From Contradiction, Anything Follows\n"
"it is of the type False.elim : False ‚Üí Œ±\n"
"\n"
"---\n"
"\n"
"**Meaning:**\n"
"\n"
"If you have a contradiction (`False`), you can conclude *any* proposition ‚Äî even something unrelated.\n"
"\n"
"This is based on a principle in classical logic called ‚Äú**Explosion**‚Äù, which states:\n"
"\n"
"Once you reach False, your system has broken, and anything can be proven.\n"
"\n"
"---\n"
"\n"
"**Intuition:**\n"
"\n"
"Think of False as a logical dead-end or crash.\n"
"\n"
"Once you've proven something impossible, the rules no longer restrict you.\n"
"\n"
"So Lean allows you to conclude any goal using False.elim.\n"
"\n"
"example (P Q : Prop) (h‚ÇÅ : P) (h‚ÇÇ : ¬¨P) : Q :=\n"
"\n"
"  False.elim (h‚ÇÇ h‚ÇÅ)\n"
"\n"
"---\n"
"\n"
"**Explanation:**\n"
"\n"
"`h‚ÇÅ : P`\n"
"\n"
"`h‚ÇÇ : ¬¨P`, i.e., `P ‚Üí False`\n"
"\n"
"Applying `h‚ÇÇ h‚ÇÅ` gives a `contradiction: False`\n"
"\n"
"Then `False.elim` produces a proof of `Q`, finishing the goal\n"
"\n"
"---\n"
"\n"
"**When to use:**\n"
"\n"
"We use `False.elim` when we've reached a contradiction, but our goal is something else ‚Äî like `Q`.\n"
"\n"
"Suppose you've reached a point in your proof where you have:\n"
"\n"
"`f : False`\n"
"\n"
"That means a contradiction has occurred.\n"
"\n"
"Lean now gives you the power to conclude anything, including your goal `Q`, because from a contradiction, any statement is considered logically valid.\n"
"\n"
"You finish the proof like this:\n"
"\n"
"`exact False.elim f`\n"
"\n"
"It tells Lean: ‚ÄúSince `False` is true here, I can conclude whatever I want ‚Äî including `Q`.\n"
"\n"
"While it may seem absurd, it follows the principle of *Explosion*, as mentioned earlier‚Äù\n"
"\n"
"---"
msgstr ""

#: Game.Levels.Propositional.L13_DisjunctiveSyllogism
msgid "You're given a disjunction `P ‚à® Q`. To proceed, you must consider both cases separately.\n"
"\n"
"Use the `cases` tactic on `¬´{h}¬ª` to split the proof into two branches: one where `P` holds and one where `Q` holds."
msgstr ""

#: Game.Levels.Propositional.L13_DisjunctiveSyllogism
msgid "You're now in the case where `P` is assumed true (`h_1 : P`), but you also have `not_p : ¬¨P` ‚Äî that is, `P ‚Üí False`.\n"
"\n"
"These two contradict each other!\n"
"\n"
"So you want to derive `False` from this contradiction, and then conclude your goal `Q` using Lean's principle that anything follows from `False`.\n"
"\n"
"Instead of writing a compound term directly inside `exact`, we can also:\n"
"\n"
"1. Use `apply False.elim` to change the goal to `False`\n"
"2. Then prove that contradiction directly\n"
"\n"
"This breaks it into more manageable steps and teaches a reusable pattern."
msgstr ""

#: Game.Levels.Propositional.L13_DisjunctiveSyllogism
msgid "After using `apply False.elim`, your goal becomes `False`.\n"
"\n"
"You already have:\n"
"\n"
"- `not_p : ¬¨P`, which is `P ‚Üí False`\n"
"- `h_1 : P`, which came from the case assumption\n"
"\n"
"Use these together: `not_p h_1` gives you `False`.\n"
"\n"
"So simply write:\n"
"\n"
"`exact not_p h_1`"
msgstr ""

#: Game.Levels.Propositional.L13_DisjunctiveSyllogism
msgid "This should be straightforward. You can try it yourself."
msgstr ""

#: Game.Levels.Propositional.L13_DisjunctiveSyllogism
msgid "Nicely done! You've applied **Disjunctive Syllogism** in this level, showing you how to:\n"
"- Split logical cases with `cases`\n"
"- Detect contradictions using `¬¨P`\n"
"- Escape contradictions using `False.elim`\n"
"\n"
"You‚Äôre now handling propositional logic like a pro."
msgstr ""

#: Game.Levels.Propositional.L14_DeMorgan
msgid "Negation of a Disjunction"
msgstr ""

#: Game.Levels.Propositional.L14_DeMorgan
msgid "Let‚Äôs practice reasoning with **negated disjunctions**.\n"
"\n"
"You're told that `¬¨(P ‚à® Q)` is true. That means **neither `P` nor `Q` can be true**.\n"
"\n"
"So your goal is to prove both `¬¨P` and `¬¨Q` ‚Äî together, this becomes `¬¨P ‚àß ¬¨Q`.\n"
"\n"
"You‚Äôll use:\n"
"- The `intro` tactic to assume one of the disjuncts\n"
"- The `apply` tactic to derive a contradiction using `¬¨(P ‚à® Q)`\n"
"- The `constructor` tactic to prove a conjunction"
msgstr ""

#: Game.Levels.Propositional.L14_DeMorgan
msgid "Begin with `constructor`. Then you will separately prove `¬¨P` and `¬¨Q`."
msgstr ""

#: Game.Levels.Propositional.L14_DeMorgan
msgid "Start with intro h."
msgstr ""

#: Game.Levels.Propositional.L14_DeMorgan
msgid "Try `apply h`."
msgstr ""

#: Game.Levels.Propositional.L14_DeMorgan
msgid "Think of `left`."
msgstr ""

#: Game.Levels.Propositional.L14_DeMorgan
msgid "Proof is just like the first half."
msgstr ""

#: Game.Levels.Propositional.L14_DeMorgan
msgid "Well done!\n"
"\n"
"You proved that if `P ‚à® Q` is false, then both `P` and `Q` must individually be false.\n"
"\n"
"This is an application of **De Morgan‚Äôs Law** in reverse ‚Äî and a great example of using elimination to handle disjunctions."
msgstr ""

#: Game.Levels.Propositional.L15_ReverseDeMorgan
msgid "Negation of a Disjunction (‚Üê)"
msgstr ""

#: Game.Levels.Propositional.L15_ReverseDeMorgan
msgid "Time to prove the **converse** of the previous level!\n"
"\n"
"You're given `¬¨P ‚àß ¬¨Q`, and need to prove `¬¨(P ‚à® Q)`.\n"
"\n"
"That is: if both `P` and `Q` are false, then the disjunction `P ‚à® Q` is also false.\n"
"\n"
"Strategy:\n"
"- Use `intro` to assume `P ‚à® Q` is true (for contradiction)\n"
"- Use `cases` to consider each case: `P` or `Q`\n"
"- In each case, derive a contradiction using `¬¨P` or `¬¨Q`"
msgstr ""

#: Game.Levels.Propositional.L15_ReverseDeMorgan
msgid "Use `intro hpq` first and then `cases hpq`. It should be doable."
msgstr ""

#: Game.Levels.Propositional.L15_ReverseDeMorgan
msgid "Great work!\n"
"\n"
"You‚Äôve now proven **both directions** of this classic equivalence:\n"
"\n"
"- `¬¨(P ‚à® Q) ‚Üí ¬¨P ‚àß ¬¨Q` (Level 14)\n"
"- `¬¨P ‚àß ¬¨Q ‚Üí ¬¨(P ‚à® Q)` (Level 15)\n"
"\n"
"Together, they form **De Morgan‚Äôs Law**:\n"
"`¬¨(P ‚à® Q) ‚Üî ¬¨P ‚àß ¬¨Q`\n"
"\n"
"This logical identity is used constantly in proofs, programming, and logic design!"
msgstr ""

#: Game.Levels.Propositional.L16_Distributivity
msgid "Distributivity of ‚àß over ‚à®"
msgstr ""

#: Game.Levels.Propositional.L16_Distributivity
msgid "In this level, we prove a fundamental logical identity:\n"
"\n"
"> `(P ‚àß (Q ‚à® R)) ‚Üî (P ‚àß Q) ‚à® (P ‚àß R)`\n"
"\n"
"This is called **distributivity** ‚Äî it shows how conjunction distributes over disjunction.\n"
"\n"
"You‚Äôll prove this *bidirectional* statement by:\n"
"- Using `constructor` to prove both directions of the equivalence\n"
"- Breaking down disjunctions using `cases`\n"
"- Building conjunctions and disjunctions using `constructor`, `left`, and `right`\n"
"\n"
"This is the final level in this World. And we use several tactics to arrive at the result. You will be prompted with obvious hints as well - to ensure that you take away a good understanding of the several tactics and their uses."
msgstr ""

#: Game.Levels.Propositional.L16_Distributivity
msgid "Use `constructor` first ‚Äî you're proving a ‚Üî, so you need to prove two implications."
msgstr ""

#: Game.Levels.Propositional.L16_Distributivity
msgid "Try `intro h`, to focus on the LHS of the implication."
msgstr ""

#: Game.Levels.Propositional.L16_Distributivity
msgid "You now have `h : P ‚àß (Q ‚à® R)`. Use `have hp := h.left` to extract the first part."
msgstr ""

#: Game.Levels.Propositional.L16_Distributivity
msgid "Then do `cases h.right` to split the `(Q ‚à® R)` into two cases."
msgstr ""

#: Game.Levels.Propositional.L16_Distributivity
msgid "Now you have `P` and `Q`. Use `left` to choose the left side of the ‚à® goal, then use `constructor` to form `P ‚àß Q`."
msgstr ""

#: Game.Levels.Propositional.L16_Distributivity
msgid "This case is similar ‚Äî now `P` and `R` are both true. Use `right` and `constructor` to build `P ‚àß R`."
msgstr ""

#: Game.Levels.Propositional.L16_Distributivity
msgid "You just finished proving the forward direction. Now `intro h` will begin the proof in the reverse direction."
msgstr ""

#: Game.Levels.Propositional.L16_Distributivity
msgid "To handle the ‚à® on the left, use `cases h` to handle each case separately."
msgstr ""

#: Game.Levels.Propositional.L16_Distributivity
msgid "You now have `hpq : P ‚àß Q`. Type `constructor` and then break it using `.left` and `.right`. Use `left` for the `Q ‚à® R`."
msgstr ""

#: Game.Levels.Propositional.L16_Distributivity
msgid "Similarly, you now have `hpr : P ‚àß R`. Use `constructor`, then `right` for the `Q ‚à® R`."
msgstr ""

#: Game.Levels.Propositional.L16_Distributivity
msgid "Beautiful!\n"
"\n"
"You‚Äôve now proven the **distributive law**:\n"
"`P ‚àß (Q ‚à® R) ‚Üî (P ‚àß Q) ‚à® (P ‚àß R)`\n"
"\n"
"By carefully analyzing the structure of each side, and using basic building blocks like `cases`, `constructor`, `left`, and `right`, you've completed a foundational logical identity.\n"
"\n"
"You'll use this reasoning in simplifying logical formulas, circuits, and more.\n"
"\n"
"With that, we have come to the end of this World. Click on the Home button at the top to explore other worlds."
msgstr ""

#: Game.Levels.Propositional.Propositional
msgid "Propositional Logic"
msgstr ""

#: Game.Levels.Propositional.Propositional
msgid "In this world, you'll explore the foundations of propositional logic.\n"
"\n"
"Each level presents a new fundamental theorem or principle.\n"
"\n"
"Before you start, take note of the panel on the right (if you are on PC). You can find the documentations/descriptions for several **Tactics** we will be making use of, and **Theorems** we will be proving(_and using_) in this World. Click on them, whether locked or unlocked, to read and understand! You are encouraged to do so whenever you are prompted to use a tactic in the game.\n"
"\n"
"Remember that you will be required to use symbols that cannot be directly found on the keyboard. A detailed guide is available if you click on `UniCode Table` on the right!\n"
"\n"
"You're ready and well equipped now.\n"
"\n"
"Click on the `Start` button to begin!"
msgstr ""

#: Game.Levels.Exercises_Propositional.L01_PracticeProp
msgid "From And to Implication"
msgstr ""

#: Game.Levels.Exercises_Propositional.L01_PracticeProp
msgid "You‚Äôre given a conjunction and an implication.\n"
"\n"
"Your task: extract the correct part from h‚ÇÅ and trigger the implication."
msgstr ""

#: Game.Levels.Exercises_Propositional.L01_PracticeProp
msgid "You extracted `P` from the conjunction and applied the implication to reach `R`. Nicely done!"
msgstr ""

#: Game.Levels.Exercises_Propositional.L02_PracticeProp
msgid "Hands On"
msgstr ""

#: Game.Levels.Exercises_Propositional.L02_PracticeProp
msgid "You've learned some of the core tactics:\n"
"- `intro` to assume\n"
"- `apply` to break down implications\n"
"- `exact` to close goals\n"
"\n"
"In this level, you‚Äôll combine multiple implications to reach a goal.\n"
"All the theorems you‚Äôve proved so far are available ‚Äî so use them!\n"
"\n"
"Try to:\n"
"- Think in chains\n"
"- Finish clearly\n"
"\n"
"(Pun intended) _Lean_ on what you know. You‚Äôve got this!"
msgstr ""

#: Game.Levels.Exercises_Propositional.L02_PracticeProp
msgid "First you need to assume `A`."
msgstr ""

#: Game.Levels.Exercises_Propositional.L02_PracticeProp
msgid "Now proceed using tactics you already know!"
msgstr ""

#: Game.Levels.Exercises_Propositional.L02_PracticeProp
msgid "You‚Äôve just walked through a chain of reasoning ‚Äî turning `A ‚Üí B ‚Üí C ‚Üí D` into `A ‚Üí D`.\n"
"\n"
"This level shows how powerful basic implication chaining is ‚Äî and how all the tactics you‚Äôve learned work together."
msgstr ""

#: Game.Levels.Exercises_Propositional.L03_PracticeProp
msgid "Modus Chain Attack"
msgstr ""

#: Game.Levels.Exercises_Propositional.L03_PracticeProp
msgid "Apply both **Modus Tollens** and **Modus Ponens** in a clean logical chain.\n"
"\n"
"Hint: Make use of the `have` tactic wherever necessary, or a nested `exact` chain!"
msgstr ""

#: Game.Levels.Exercises_Propositional.L03_PracticeProp
msgid "Excellent. You combined two powerful rules ‚Äî **Modus Tollens** and **Modus Ponens** ‚Äî using structured steps."
msgstr ""

#: Game.Levels.Exercises_Propositional.L04_PracticeProp
msgid "Another Modus Chain"
msgstr ""

#: Game.Levels.Exercises_Propositional.L04_PracticeProp
msgid "Apply both **Modus Tollens** and **Modus Ponens** in a clean logical chain.\n"
"\n"
"Hint: Make use of the `have` tactic wherever necessary, or a nested `exact` chain!"
msgstr ""

#: Game.Levels.Exercises_Propositional.L04_PracticeProp
msgid "Excellent. You combined two powerful rules ‚Äî **Modus Tollens** and **Modus Ponens** ‚Äî using structured steps."
msgstr ""

#: Game.Levels.Exercises_Propositional.L05_PracticeProp
msgid "Disjunctive Detour"
msgstr ""

#: Game.Levels.Exercises_Propositional.L05_PracticeProp
msgid "Time to bring in disjunctions (`P ‚à® Q`)!\n"
"\n"
"You‚Äôre given:\n"
"\n"
"- `h‚ÇÅ : P ‚à® Q`\n"
"- `h‚ÇÇ : Q ‚Üí ¬¨R`\n"
"- `h‚ÇÉ : ¬¨P`\n"
"\n"
"Your goal is to prove `¬¨R`.\n"
"\n"
"You‚Äôll need to use:\n"
"- `intro` first.\n"
"- The `cases` tactic to split the disjunction\n"
"- `have` to name intermediate steps\n"
"- Possibly use contradiction to eliminate impossible paths"
msgstr ""

#: Game.Levels.Exercises_Propositional.L05_PracticeProp
msgid "Excellent! You split the disjunction and handled both cases carefully:\n"
"- The first led to contradiction with `¬¨P`\n"
"- The second allowed you to conclude `¬¨R`\n"
"\n"
"This is classic **disjunction reasoning** paired with a chain of implications."
msgstr ""

#: Game.Levels.Exercises_Propositional.Exercises_Propositional
msgid "Exercises - Propositional"
msgstr ""

#: Game.Levels.Exercises_Propositional.Exercises_Propositional
msgid "In this world, you'll try out some exercises on propositional logic, based on the knowledge gained so far.\n"
"\n"
"Before you start, take note of the panel on the right (if you are on PC). You can find the documentations/descriptions for several **Tactics** we will be making use of, and **Theorems** we will be proving(_and using_) in this World. Click on them, whether locked or unlocked, to read and understand! You are encouraged to do so whenever you are prompted to use a tactic in the game.\n"
"\n"
"Click on the `Start` button to begin!"
msgstr ""

#: Game.Levels.Predicate.L1
msgid "What‚Äôs a Predicate?"
msgstr ""

#: Game.Levels.Predicate.L1
msgid "Welcome to **Predicate Logic**!\n"
"\n"
"In propositional logic, you worked with full statements which were assigned truth values - `True` or `False`.\n"
"In predicate logic, we work with **statements that depend on a variable**.\n"
"\n"
"These are called **predicates**.\n"
"\n"
"For instance:\n"
"> Let `P(x)` mean ‚Äúx is a student‚Äù.\n"
"\n"
"This is not a full proposition until we plug in a value like `P(Alice)`, where Alice, is a student.\n"
"\n"
"Let‚Äôs see how to use one!\n"
"\n"
"*Note: `P x` and `P (x)` mean the same. Lean removes the parantheses by default. It's like a function `f` applied onto a variable `x` (the function here is a proposition).*"
msgstr ""

#: Game.Levels.Predicate.L1
msgid "You want to prove `Q a`, and you have a rule: `‚àÄ x, P x ‚Üí Q x`, which reads: For all `x`, `P x ‚Üí Q x`.\n"
"\n"
"`apply` that rule at the specific value `a`, just like how we did in Propositional Logic. Do `apply h` or `apply h a"
msgstr ""

#: Game.Levels.Predicate.L1
msgid "Now Lean wants you to prove `P a`, which you already have from `hP`."
msgstr ""

#: Game.Levels.Predicate.L1
msgid "Nice work! üéâ\n"
"\n"
"You just used a predicate rule to prove a specific case.\n"
"\n"
"This is the core idea of predicate logic:\n"
"General statements like `‚àÄ x, P (x) ‚Üí Q (x)` can be instantiated at a specific value.\n"
"\n"
"And Lean handles it just like functions!"
msgstr ""

#: Game.Levels.Predicate.L2
msgid "Universal Elimination"
msgstr ""

#: Game.Levels.Predicate.L2
msgid "Let‚Äôs dive deeper into **universal statements** ‚Äî ones that say something is true for *every* value.\n"
"\n"
"For example:\n"
"> \"Everyone is a student\" would mean `‚àÄ x, P(x)`, which means, for all `x`, `P(x)` is true, which simply means, for all `x`, ‚Äúx is a student‚Äù.\n"
"\n"
"Once we know something is true for **all** values, we can plug in any specific one.\n"
"\n"
"So from `‚àÄ x, P(x)`, we can conclude `P(a)`, for some value `a` ‚Äî this is called **universal elimination**.\n"
"\n"
"*Note: `P x` and `P (x)` mean the same. Lean removes the parentheses by default.*"
msgstr ""

#: Game.Levels.Predicate.L2
msgid "You are given `h : ‚àÄ x, P x`, and want to prove `P a`.\n"
"\n"
"If it wasn't obvious, yes, we will make use of the `apply` tactic, `apply h`."
msgstr ""

#: Game.Levels.Predicate.L2
msgid "Nice work! üéâ\n"
"\n"
"You‚Äôve just used **universal elimination** ‚Äî plugging a value into a statement that's true for all.\n"
"\n"
"From `‚àÄ x, P(x)` you derived `P(a)`. This is one of the most common and powerful rules in predicate logic!"
msgstr ""

#: Game.Levels.Predicate.L3
msgid "Existential Introduction"
msgstr ""

#: Game.Levels.Predicate.L3
msgid "Time to look at **existential statements** ‚Äî ones that say *something exists*.\n"
"\n"
"For example:\n"
"> \"There exists a student\" means `‚àÉ x, P(x)`, which means, for some `x`, `P(x)` is true, which simply means, for some `x`, ‚Äúx is a student‚Äù. There could be more than one such `x` value. But there **definitely is one `x`** for which it is true.\n"
"\n"
"To prove this, it‚Äôs enough to show one example:\n"
"If you can prove `P(a)` for some `a`, then `‚àÉ x, P(x)` is true.\n"
"\n"
"This is called **existential introduction**.\n"
"\n"
"*Note: `P x` and `P (x)` mean the same. Lean just omits the parentheses by default.*"
msgstr ""

#: Game.Levels.Predicate.L3
msgid "The constructor `Exists.intro` is used to prove an existential statement.\n"
"  Given a value `a : Œ±` and a proof `h : P a`, `Exists.intro a h` proves `‚àÉ x, P x`."
msgstr ""

#: Game.Levels.Predicate.L3
msgid "You are trying to prove `‚àÉ x, P x`. That means you need to provide a witness ‚Äî a specific value ‚Äî and show that it satisfies `P`.\n"
"\n"
"Once you have `P a`, it is straightforward.'\n"
"\n"
"But you already have `P a`. So we do need to make use of the `exact` tactic.\n"
"\n"
"The syntax is a bit different though. You need to type in `exact ‚ü®a, h‚ü©`.\n"
"\n"
"But this can look a bit complicated. So we make use of `Exists.intro`. Read more about it by clicking its documentation on the right."
msgstr ""

#: Game.Levels.Predicate.L3
msgid "With `Exists.intro`, we are building a value of type `‚àÉ x, P x` by giving:\n"
"- `a`: the specific value (the witness)\n"
"- `h`: a proof that `P a` is true\n"
"\n"
"Use the constructor `Exists.intro a h`, written after `exact`, to build the required object."
msgstr ""

#: Game.Levels.Predicate.L3
msgid "Great job! üéâ\n"
"\n"
"You‚Äôve just used existential introduction by giving an example where the predicate holds.\n"
"\n"
"From P(a), you concluded `‚àÉ x, P(x)` ‚Äî saying that at least one such `x` exists."
msgstr ""

#: Game.Levels.Predicate.L4
msgid "Existential Elimination"
msgstr ""

#: Game.Levels.Predicate.L4
msgid "You've seen how to *prove* that something exists. Now let‚Äôs see how to *use* such a fact.\n"
"\n"
"Suppose you're told:\n"
"\n"
"> \"There exists an `x` such that `P(x)` is true\" ‚Äî written as `‚àÉ x, P(x)`\n"
"\n"
"This means:\n"
"> \"Some value satisfies the property `P` ‚Äî but we don‚Äôt know which one yet.\"\n"
"\n"
"To work with this, we can use the `cases` tactic to:\n"
"1. Pull out a specific witness - `x`.\n"
"2. Pull out the proof that this witness satisfies `P` - `hx`.\n"
"\n"
"This is called **existential elimination**.\n"
"\n"
"*Note: `P x` and `P (x)` mean the same thing ‚Äî Lean just omits the parentheses by default.*"
msgstr ""

#: Game.Levels.Predicate.L4
msgid "Use `cases h` to extract the witness `w` and the proof `h_1 : P w`."
msgstr ""

#: Game.Levels.Predicate.L4
msgid "Now you have `w : Œ±` and `h_1 : P w`. Use the universal statement `hQ : ‚àÄ w, P w ‚Üí Q`.\n"
"\n"
"It wouldn't be just `apply hQ`. We also need to specify which element we are working on, which is `w` in this case. So do `apply hQ w`."
msgstr ""

#: Game.Levels.Predicate.L4
msgid "Lean wants you to prove `P w`, which you have as `h_1`."
msgstr ""

#: Game.Levels.Predicate.L4
msgid "Nice! üéâ\n"
"\n"
"You just performed existential elimination:\n"
"\n"
"You started with `‚àÉ w, P (w).`\n"
"\n"
"Then used `cases` to extract a witness and its property and applied a general rule to that specific value.\n"
"\n"
"This is actually one of the most important tools for reasoning about existential statements."
msgstr ""

#: Game.Levels.Predicate.L5
msgid "Nested Quantifiers"
msgstr ""

#: Game.Levels.Predicate.L5
msgid "You‚Äôve worked with `‚àÄ` and `‚àÉ` individually. Now let‚Äôs **combine** them.\n"
"\n"
"Suppose we‚Äôre told:\n"
"> \"For every `x`, there exists a `y` such that `P(x, y)` holds.\"\n"
"\n"
"That‚Äôs written as:\n"
"```lean\n"
"‚àÄ x, ‚àÉ y, P(x, y)\n"
"```\n"
"In Lean, you can treat universal quantifiers (`‚àÄ`) like functions.\n"
"\n"
"So:\n"
"\n"
"```lean\n"
"h : ‚àÄ x, ‚àÉ y, P(x, y)\n"
"a : Œ±\n"
"```\n"
"\n"
"Then we get to\n"
"```lean\n"
"h a : ‚àÉ y, P(a, y)\n"
"```\n"
"\n"
"Let's try to break this down!"
msgstr ""

#: Game.Levels.Predicate.L5
msgid "You want to prove `‚àÉ y, P a y`, and you have a general rule: `‚àÄ x, ‚àÉ y, P x y`.\n"
"\n"
"`apply h` to `a` to get: `‚àÉ y, P a y`.\n"
"\n"
"Both `apply h` and `apply h a` work the same. Though it is just a one line proof, it is quite crucial to understand this step."
msgstr ""

#: Game.Levels.Predicate.L5
msgid "Awesome! üéâ\n"
"\n"
"You just worked with a nested quantifier:\n"
"\n"
"`h : ‚àÄ x, ‚àÉ y, P(x, y)` means every `x` has its own matching `y`\n"
"\n"
"By applying it to a specific `a`, you got `‚àÉ y, P(a, y)`.\n"
"\n"
"This pattern ‚Äî universal followed by existential ‚Äî is very common in mathematical reasoning."
msgstr ""

#: Game.Levels.Predicate.L6
msgid "Existential Before Universal"
msgstr ""

#: Game.Levels.Predicate.L6
msgid "Let‚Äôs look at **another nesting** of quantifiers ‚Äî this time:\n"
"\n"
"> \"There exists an `x` such that for every `y`, `P(x, y)` holds.\"\n"
"\n"
"This is written:\n"
"```lean\n"
"‚àÉ x, ‚àÄ y, P(x, y)\n"
"```\n"
"This means there is one special `x` that works for all `y`.\n"
"\n"
"So to prove a particular P(a, b), it‚Äôs enough to:\n"
"- Pull out that special `x`\n"
"- Apply the universal rule for `y = b`\n"
"\n"
"We‚Äôll use a combination of `intro` and `exact`."
msgstr ""

#: Game.Levels.Predicate.L6
msgid "You want to prove a universal statement: `‚àÄ y, P a y ‚Üí ‚àÉ x, P x y.`\n"
"\n"
"This means we should assume an arbitrary value of `y`, and a hypothesis that `P a y` holds.\n"
"\n"
"Use the intro tactic twice to bring them into the context : `intro y hy`"
msgstr ""

#: Game.Levels.Predicate.L6
msgid "Now your goal is: `‚àÉ x, P x y`.\n"
"\n"
"You already have a proof of `P a y` (it's called `hy`).\n"
"\n"
"To prove that there exists such an `x`, it‚Äôs enough to give a specific example ‚Äî and you know that `a` works!\n"
"\n"
"Use the `Exists.intro`syntax to finish off (with `exact`)."
msgstr ""

#: Game.Levels.Predicate.L6
msgid "Awesome! üéâ\n"
"\n"
"You just worked through a nested quantifier goal ‚Äî in the reverse direction from before.\n"
"\n"
"From:\n"
"```lean\n"
"P a y\n"
"```\n"
"you concluded:\n"
"```lean\n"
"‚àÉ x, P x y\n"
"```\n"
"This is called **existential introduction** ‚Äî and you used the value `a` as your witness.\n"
"\n"
"Pay attention to the order of quantifiers:\n"
"\n"
"`‚àÄ x, ‚àÉ y` means each `x` may have its own `y`\n"
"\n"
"`‚àÉ x, ‚àÄ y` means one single `x` works for every `y`\n"
"\n"
"These are not logically equivalent ‚Äî and you now understand how to prove statements from both."
msgstr ""

#: Game.Levels.Predicate.L7
msgid "Negating ‚àÉ"
msgstr ""

#: Game.Levels.Predicate.L7
msgid "Let‚Äôs learn how to reason with a **negated existential** statement.\n"
"\n"
"Suppose you‚Äôre told:\n"
"> ‚ÄúThere is **no** value of `x` for which `P(x)` is true.‚Äù\n"
"\n"
"That‚Äôs written as:\n"
"```lean\n"
"¬¨ (‚àÉ x, P x)\n"
"```\n"
"This means:\n"
"\n"
"‚ÄúFor every `x`, `P(x)` must be false‚Äù ‚Äî or in logic terms:\n"
"```lean\n"
"‚àÄ x, ¬¨ P x\n"
"```\n"
"We‚Äôll now prove this!"
msgstr ""

#: Game.Levels.Predicate.L7
msgid "Your goal is to prove `‚àÄ x, ¬¨ P x`.\n"
"\n"
"So first, assume an arbitrary `x` using `intro x`."
msgstr ""

#: Game.Levels.Predicate.L7
msgid "Now you want to prove `¬¨ P x`. This means: assume `P x` and derive a contradiction.\n"
"\n"
"Use `intro hPx` to assume `P x`."
msgstr ""

#: Game.Levels.Predicate.L7
msgid "Now think: If you know that `P x` is true, then you can say:\n"
"\n"
"'There exists some x such that P x is true.'\n"
"\n"
"Lean lets you write that as:\n"
"```lean\n"
"exact Exists.intro x hPx\n"
"```\n"
"But it can be packed better with the angular brackets as you read in Level 3.\n"
"\n"
"```lean\n"
"‚ü®x, hPx‚ü©\n"
"```\n"
"This is a value of type `‚àÉ x, P x` ‚Äî a witness `x` and proof `hPx`.\n"
"\n"
"So use:\n"
"```lean\n"
"exact h ‚ü®x, hPx‚ü©\n"
"```\n"
"\n"
"This says: ‚ÄúHere‚Äôs an example of something that shouldn‚Äôt exist,‚Äù and Lean will conclude a contradiction."
msgstr ""

#: Game.Levels.Predicate.L7
msgid "If you notice, this looks a bit similar to stuff that we have encountered in Propositional Logic.\n"
"\n"
"`exact ¬¨P P` and `exact ¬¨(‚àÉ x, P x) (‚àÉ x, P x)`, both result in `False`.\n"
"\n"
"The structure in the exact statement you're about to use, resembles `exact ¬¨(‚àÉ x, P x) (‚àÉ x, P x)`. It is now time for you to observe the pattern!"
msgstr ""

#: Game.Levels.Predicate.L7
msgid "Awesome! üéâ\n"
"\n"
"You just proved that:\n"
"```lean\n"
"¬¨ (‚àÉ x, P x) ‚Üí ‚àÄ x, ¬¨ P x\n"
"```\n"
"This is a powerful logical transformation.\n"
"\n"
"*Key idea:* To prove something doesn‚Äôt exist, show that any attempt to build it leads to contradiction."
msgstr ""

#: Game.Levels.Predicate.L8
msgid "A Counterexample Exists"
msgstr ""

#: Game.Levels.Predicate.L8
msgid "Let‚Äôs try something easier ‚Äî and more concrete!\n"
"\n"
"Suppose we know that `P(a)` is **not true**.\n"
"\n"
"Then we can conclude:\n"
"> ‚ÄúThere exists some x for which `P(x)` is not true.‚Äù\n"
"\n"
"In logic:\n"
"```lean\n"
"h : ¬¨ P a\n"
"‚ä¢ ‚àÉ x, ¬¨ P x\n"
"```\n"
"\n"
"We‚Äôre simply providing a specific example (a counterexample!) to prove an existential statement.\n"
"\n"
"Let‚Äôs try it!"
msgstr ""

#: Game.Levels.Predicate.L8
msgid "Your goal is to prove `‚àÉ x, ¬¨ P x`.\n"
"\n"
"You already know a specific `a` where `P a` is not true ‚Äî it‚Äôs given by `h`.\n"
"\n"
"So you can just provide `a` as the witness, and `h` as the proof.\n"
"```lean\n"
"exact Exists.intro a h\n"
"```"
msgstr ""

#: Game.Levels.Predicate.L8
msgid "Perfect! üéâ\n"
"\n"
"You just gave a **counterexample** to the statement `‚àÄ x, P x`.\n"
"\n"
"You showed that:\n"
"```lean\n"
"P a is false ‚áí ‚àÉ x, P x is false\n"
"```\n"
"This is one of the cleanest uses of existential introduction ‚Äî and a very common pattern in proofs!\n"
"\n"
"It might just be a one line proof, but again, we're going step by step to make sure that your understanding is complete."
msgstr ""

#: Game.Levels.Predicate.L9
msgid "Existential + Universal"
msgstr ""

#: Game.Levels.Predicate.L9
msgid "Let‚Äôs combine **existential** and **universal** logic with a conjunction.\n"
"\n"
"You are given:\n"
"\n"
"- `‚àÉ w, P w` ‚Äî There exists some `w` such that `P w` holds\n"
"- `‚àÄ w, P w ‚Üí Q w` ‚Äî For all `w`, if `P w` holds, then `Q w` also holds\n"
"\n"
"Your goal is to prove:\n"
"\n"
"`‚àÉ w, P w ‚àß Q w` ‚Äî There exists some `w` such that both `P w` and `Q w` are true.\n"
"\n"
"We‚Äôll do this using the constructors `And.intro` and `Exists.intro`."
msgstr ""

#: Game.Levels.Predicate.L9
msgid "Constructs a proof of `P ‚àß Q` given proofs of `P` and `Q`."
msgstr ""

#: Game.Levels.Predicate.L9
msgid "We want to extract a specific witness from the existential statement `h‚ÇÅ`.\n"
"\n"
"Use `cases h‚ÇÅ` to pull out:\n"
"\n"
"a value `w : Œ±`\n"
"\n"
"and a proof `h : P w`"
msgstr ""

#: Game.Levels.Predicate.L9
msgid "From `h‚ÇÇ : ‚àÄ w, P w ‚Üí Q w`, you can specialize it to the specific `w` using:\n"
"\n"
"`have hPwtQw : P w ‚Üí Q w := h‚ÇÇ w`\n"
"This gives you a conditional statement just for this particular `w`."
msgstr ""

#: Game.Levels.Predicate.L9
msgid "Now apply Modus Ponens.\n"
"\n"
"You have:\n"
"\n"
"`P w ‚Üí Q w` as `hPwtQw`\n"
"\n"
"`P w` as `h`\n"
"\n"
"So you can deduce `Q w` as `hQw` with the `have` tactic."
msgstr ""

#: Game.Levels.Predicate.L9
msgid "Now you have both `P w` and `Q w`.\n"
"\n"
"You can combine them using `And.intro h hQw` to get `P w ‚àß Q w`.\n"
"\n"
"Then use `Exists.intro w (...)` to finish the proof:\n"
"```lean\n"
"exact Exists.intro w (And.intro h hQw)\n"
"```"
msgstr ""

#: Game.Levels.Predicate.L9
msgid "Awesome! üéâ\n"
"\n"
"You used:\n"
"\n"
"`cases` to extract a witness from an existential\n"
"\n"
"A universal implication to derive new information\n"
"\n"
"`And.intro` to build a conjunction\n"
"\n"
"`Exists.intro` to reintroduce the existential\n"
"\n"
"These steps form a solid foundation for more advanced logic proofs ahead."
msgstr ""

#: Game.Levels.Predicate.Predicate
msgid "Predicate Logic"
msgstr ""

#: Game.Levels.Predicate.Predicate
msgid "In this world, you'll explore the foundations of **predicate logic**.\n"
"\n"
"Each level presents a new fundamental theorem or principle.\n"
"\n"
"Before you start, take note of the panel on the right (if you are on PC). You can find the documentations/descriptions for several **Tactics** we will be making use of, and **Theorems** we will be proving(_and using_) in this World. Click on them, whether locked or unlocked, to read and understand! You are encouraged to do so whenever you are prompted to use a tactic in the game.\n"
"\n"
"Click on the `Start` button to begin!"
msgstr ""

#: Game.Levels.Sets.L01
msgid "Set Membership"
msgstr ""

#: Game.Levels.Sets.L01
msgid "Welcome to the world of **Set Theory**!\n"
"\n"
"Sets are collections of objects. We write `x ‚àà A` to say that *element x is in set A*.\n"
"\n"
"This level introduces one of the most fundamental ideas: **membership**.\n"
"\n"
"In Lean, we work with `x ‚àà A` as a proposition, which we can use in proofs.\n"
"\n"
"Let‚Äôs prove something simple!"
msgstr ""

#: Game.Levels.Sets.L01
msgid "You are trying to prove `x ‚àà A`. And you already have `h : x ‚àà A`.\n"
"\n"
"Just use `exact h` to complete the proof."
msgstr ""

#: Game.Levels.Sets.L01
msgid "Great start!\n"
"\n"
"You‚Äôve just used a given assumption to complete a proof.\n"
"\n"
"Set membership (`x ‚àà A`) is one of the most basic ideas in math ‚Äî and you‚Äôll use it a lot in upcoming levels."
msgstr ""

#: Game.Levels.Sets.L02
msgid "Subset Intro"
msgstr ""

#: Game.Levels.Sets.L02
msgid "Let‚Äôs now talk about **subsets**.\n"
"\n"
"We write `A ‚äÜ B` to mean *every element of A is also an element of B*. That is: `‚àÄ x, x ‚àà A ‚Üí x ‚àà B`\n"
"\n"
"This level helps you prove that every set is a subset of itself, using basic logic and the `intro` and `exact` tactics."
msgstr ""

#: Game.Levels.Sets.L02
msgid "In order to do this proof in Lean, we use `intro x` to introduce an element `x` which belongs to both sets. Then, `intro h` assumes `x ‚àà A` is true, then we write `exact h`.\n"
"\n"
"You are proving `A ‚äÜ A`, which means: for all `x`, if `x ‚àà A` then `x ‚àà A`."
msgstr ""

#: Game.Levels.Sets.L02
msgid "Well done!\n"
"\n"
"You've just proved that a set is a subset of itself ‚Äî this is called **reflexivity** of subsets.\n"
"\n"
"You'll use this idea as a stepping stone for more complex subset proofs."
msgstr ""

#: Game.Levels.Sets.L03
msgid "Subset via Chain"
msgstr ""

#: Game.Levels.Sets.L03
msgid "Let‚Äôs now apply the idea of subset proofs with some logical chaining.\n"
"\n"
"You're given:\n"
"- `A ‚äÜ B`\n"
"- `B ‚äÜ C`\n"
"\n"
"Your task: Prove that `A ‚äÜ C`.\n"
"\n"
"This is called the **transitivity of subsets** ‚Äî if everything in `A` is in `B`, and everything in `B` is in `C`, then everything in `A` must be in `C` as well.\n"
"\n"
"Use `intro` to assume an arbitrary element and its membership, and then chain your reasoning using `exact`."
msgstr ""

#: Game.Levels.Sets.L03
msgid "Start by assuming an arbitrary element from `A` using `intro x`."
msgstr ""

#: Game.Levels.Sets.L03
msgid "Assume that `x ‚àà A` using `intro h`."
msgstr ""

#: Game.Levels.Sets.L03
msgid "Since `h‚ÇÅ : A ‚äÜ B`, and `h : x ‚àà A`, you can use `have` to create `x ‚àà B`."
msgstr ""

#: Game.Levels.Sets.L03
msgid "This is analogous to `h‚ÇÅ : P ‚Üí Q` and `h : P`. To prove `Q`, we would write `have hq: Q := modus_ponens h‚ÇÅ h`. In fact, even `have hq: Q := h‚ÇÅ h` would work!"
msgstr ""

#: Game.Levels.Sets.L03
msgid "In our case now, we would write something very similar : `have xb : x ‚àà B := h‚ÇÅ h`. But this is not fully correct. We need to keep in mind that we're dealing with Sets, not Propositions. Hence, we must specify which member of the set we are actually talking about; in this case - `x`."
msgstr ""

#: Game.Levels.Sets.L03
msgid "So the correct command would be : `have xb : x ‚àà B := h‚ÇÅ x h`."
msgstr ""

#: Game.Levels.Sets.L03
msgid "Now use `h‚ÇÇ : B ‚äÜ C` to conclude that `x ‚àà C`, similar to the previous command."
msgstr ""

#: Game.Levels.Sets.L03
msgid "Nice work!\n"
"\n"
"This was an example of **chaining subset relations**, and formally proves that subsets are transitive:\n"
"\n"
"If `A ‚äÜ B` and `B ‚äÜ C`, then `A ‚äÜ C`.\n"
"\n"
"You‚Äôll use this kind of reasoning a lot in set theory."
msgstr ""

#: Game.Levels.Sets.L04
msgid "Subset of Intersection"
msgstr ""

#: Game.Levels.Sets.L04
msgid "Let‚Äôs prove something involving **intersection of sets**.\n"
"\n"
"You are given:\n"
"- `A ‚äÜ B`\n"
"- `A ‚äÜ C`\n"
"\n"
"You are asked to prove:\n"
"- `A ‚äÜ B ‚à© C`\n"
"\n"
"Remember, intersection (`B ‚à© C`) means the set of all elements that are in **both** `B` and `C`.\n"
"\n"
"So this level asks: if everything in `A` is in both `B` and `C`, can we say `A` is a subset of `B ‚à© C`?\n"
"\n"
"Let‚Äôs find out!"
msgstr ""

#: Game.Levels.Sets.L04
msgid "You're proving a subset relation. Start with `intro x` and then `intro h` to assume `x ‚àà A`."
msgstr ""

#: Game.Levels.Sets.L04
msgid "You want to prove `x ‚àà B ‚à© C`, which means both `x ‚àà B` and `x ‚àà C`.\n"
"\n"
"Use `have` twice ‚Äî once to get `x ‚àà B` from `hAB`, and once to get `x ‚àà C` from `hAC`."
msgstr ""

#: Game.Levels.Sets.L04
msgid "Now construct the pair `(xb, xc)` using the `constructor` tactic. That will prove `x ‚àà B ‚à© C`."
msgstr ""

#: Game.Levels.Sets.L04
msgid "Excellent work!\n"
"\n"
"You've shown that if everything in `A` is in both `B` and `C`, then everything in `A` is also in their intersection.\n"
"\n"
"This is one of the most common patterns in set theory ‚Äî you'll use it a lot going forward."
msgstr ""

#: Game.Levels.Sets.L05
msgid "Unpack Both Sides"
msgstr ""

#: Game.Levels.Sets.L05
msgid "Let‚Äôs make things a little more interesting.\n"
"\n"
"You‚Äôre given: `x ‚àà A ‚à© B`\n"
"\n"
"Your goal is to show: `x ‚àà B ‚à© A`\n"
"\n"
"This may seem trivial, but it helps build the skill of **manipulating set expressions** using logical tools.\n"
"\n"
"The key is to:\n"
"- Extract both parts of the intersection from `h : x ‚àà A ‚à© B`\n"
"- Recombine them in reverse order using `constructor`."
msgstr ""

#: Game.Levels.Sets.L05
msgid "We use this to show `A ‚à© B ‚äÜ B ‚à© A`"
msgstr ""

#: Game.Levels.Sets.L05
msgid "Start with `intro x`, then `intro h` to assume `x ‚àà A ‚à© B`."
msgstr ""

#: Game.Levels.Sets.L05
msgid "`h` is a pair: `x ‚àà A ‚àß x ‚àà B`.\n"
"\n"
"Use `h.left` to get `x ‚àà A`, and `h.right` to get `x ‚àà B` using `have` tactic."
msgstr ""

#: Game.Levels.Sets.L05
msgid "Now use `constructor` to prove `x ‚àà B ‚à© A`, which means `x ‚àà B ‚àß x ‚àà A`."
msgstr ""

#: Game.Levels.Sets.L05
msgid "Awesome!\n"
"\n"
"You just took apart an intersection and built a new one in reverse.\n"
"\n"
"This simple trick underpins many proofs involving **set equalities** ‚Äî where you must show two sets contain the same elements."
msgstr ""

#: Game.Levels.Sets.L06
msgid "Commutativity of Intersection"
msgstr ""

#: Game.Levels.Sets.L06
msgid "Time for your first **set equality** proof!\n"
"\n"
"You‚Äôre proving that: `A ‚à© B = B ‚à© A`\n"
"\n"
"That means:\n"
"- every element of `A ‚à© B` is in `B ‚à© A` (*left-to-right*),\n"
"- and every element of `B ‚à© A` is in `A ‚à© B` (*right-to-left*).\n"
"\n"
"This is called the **commutativity of intersection**.\n"
"\n"
"You already proved both directions separately before ‚Äî now combine them together!"
msgstr ""

#: Game.Levels.Sets.L06
msgid "To prove set equality, use `constructor` to break the goal into two subset goals: `‚äÜ` in both directions.\n"
"\n"
"Note: `Equal (A ‚à© B) (B ‚à© A)` is the same as `A ‚à© B = B ‚à© A`"
msgstr ""

#: Game.Levels.Sets.L06
msgid "Before you do this manually, we just did it last level! How about use the theorem from last level itself?"
msgstr ""

#: Game.Levels.Sets.L06
msgid "Do `exact A_and_B_subset_B_and_A A B`."
msgstr ""

#: Game.Levels.Sets.L06
msgid "Now prove the reverse direction using the same pattern."
msgstr ""

#: Game.Levels.Sets.L06
msgid "Excellent!\n"
"\n"
"You‚Äôve now formally proved that intersection is **commutative** ‚Äî the order of sets doesn't matter.\n"
"\n"
"This idea appears often when simplifying or rearranging set expressions."
msgstr ""

#: Game.Levels.Sets.L07
msgid "Union Superset"
msgstr ""

#: Game.Levels.Sets.L07
msgid "Let‚Äôs now bring in a new set operation ‚Äî **union**.\n"
"\n"
"We write `A ‚à™ B` for the union of two sets, which means:\n"
"> all elements that are in `A`, or in `B`, or in both.\n"
"\n"
"In this level, you're asked to prove:\n"
"> `A ‚äÜ A ‚à™ B`\n"
"\n"
"In words:\n"
"Every element of `A` is definitely in the union `A ‚à™ B`.\n"
"\n"
"Lean will require you to **choose the correct branch** of the union ‚Äî use what you‚Äôve learned about proving disjunctions."
msgstr ""

#: Game.Levels.Sets.L07
msgid "Start with `intro x` and `intro h` ‚Äî you're assuming `x ‚àà A` and must prove `x ‚àà A ‚à™ B`, i.e., `x ‚àà A ‚à® x ‚àà B`."
msgstr ""

#: Game.Levels.Sets.L07
msgid "Since `x ‚àà A`, you can conclude `x ‚àà A ‚à® x ‚àà B` by using the `left` tactic. It tells Lean: 'I‚Äôll prove the left side of the disjunction.'"
msgstr ""

#: Game.Levels.Sets.L07
msgid "Perfect!\n"
"\n"
"This is a very important property: every set is a subset of its own union.\n"
"\n"
"You‚Äôll now explore more properties of unions in the next levels."
msgstr ""

#: Game.Levels.Sets.L08
msgid "Breaking a Union"
msgstr ""

#: Game.Levels.Sets.L08
msgid "Previously, you proved that every element of `A` is also in `A ‚à™ B`.\n"
"\n"
"Now you‚Äôll do the **reverse**:\n"
"You‚Äôre given `x ‚àà A ‚à™ B`, and must show that `x ‚àà B ‚à™ A`.\n"
"\n"
"Even though the goal is another union, this time your **assumption** is a union. That means you‚Äôll need to break it apart using `cases`.\n"
"\n"
"This level helps you understand how **disjunction elimination** works in the context of sets."
msgstr ""

#: Game.Levels.Sets.L08
msgid "Start with `intro x` and `intro h` to assume `x ‚àà A ‚à™ B`."
msgstr ""

#: Game.Levels.Sets.L08
msgid "`h` is a disjunction ‚Äî `x ‚àà A ‚à® x ‚àà B`. Use `cases h` to split into two possibilities."
msgstr ""

#: Game.Levels.Sets.L08
msgid "`x ‚àà A` is true in this branch. So, to prove `x ‚àà B ‚à™ A`, use `right` ‚Äî you want to show the second part of the union."
msgstr ""

#: Game.Levels.Sets.L08
msgid "`x ‚àà B` is true here. So, use `left` to show the first part holds."
msgstr ""

#: Game.Levels.Sets.L08
msgid "Well done!\n"
"\n"
"You just deconstructed a union and rearranged it ‚Äî this is part of proving the **commutativity** of union.\n"
"\n"
"Later, you'll use this pattern in longer, chained proofs."
msgstr ""

#: Game.Levels.Sets.L09
msgid "Commutativity of Union"
msgstr ""

#: Game.Levels.Sets.L09
msgid "You‚Äôre now ready to prove that `A ‚à™ B = B ‚à™ A` ‚Äî that is, **union is commutative**.\n"
"\n"
"From earlier levels:\n"
"- You proved `A ‚äÜ A ‚à™ B` and `A ‚à™ B ‚äÜ B ‚à™ A`.\n"
"- You‚Äôve learned how to split and construct disjunctions using `cases`, `left`, and `right`.\n"
"\n"
"Now, use these together to prove **both directions** of the subset relation."
msgstr ""

#: Game.Levels.Sets.L09
msgid "To prove set equality, start with `constructor` to break the goal into two subset proofs: `‚äÜ` in both directions."
msgstr ""

#: Game.Levels.Sets.L09
msgid "Assume an arbitrary element `x : ‚Ñï`, and a hypothesis `h : x ‚àà A ‚à™ B`."
msgstr ""

#: Game.Levels.Sets.L09
msgid "`h` is a disjunction ‚Äî `x ‚àà A ‚à® x ‚àà B`. Use `cases h` to split into the two cases."
msgstr ""

#: Game.Levels.Sets.L09
msgid "`x ‚àà A` holds here. Since your goal is `x ‚àà B ‚à™ A`, use `right` to focus on the second part of the union."
msgstr ""

#: Game.Levels.Sets.L09
msgid "`x ‚àà B` holds here. So use `left` to show `x ‚àà B ‚à™ A` by focusing on the first part."
msgstr ""

#: Game.Levels.Sets.L09
msgid "Then repeat the same reasoning, but with `B ‚à™ A` on the left side."
msgstr ""

#: Game.Levels.Sets.L09
msgid "You can take it from here."
msgstr ""

#: Game.Levels.Sets.L09
msgid "Great work!\n"
"\n"
"You‚Äôve now proved that **union is commutative** ‚Äî just like intersection.\n"
"\n"
"This reinforces how logic and set theory walk hand-in-hand!"
msgstr ""

#: Game.Levels.Sets.L10
msgid "Distributivity of ‚à© over ‚à™"
msgstr ""

#: Game.Levels.Sets.L10
msgid "Let‚Äôs take things up a notch!\n"
"\n"
"In this level, you‚Äôll prove:\n"
"\n"
"`A ‚à© (B ‚à™ C) = (A ‚à© B) ‚à™ (A ‚à© C)`.\n"
"\n"
"This is called the **distributivity of intersection over union** ‚Äî it lets you simplify nested set expressions logically.\n"
"\n"
"You‚Äôll combine everything you‚Äôve seen so far:\n"
"- `constructor` for set equality\n"
"- `cases` to break disjunctions\n"
"- `.left` / `.right` for conjunctions\n"
"- `left` / `right` to construct disjunctions"
msgstr ""

#: Game.Levels.Sets.L10
msgid "To prove set equality, use `constructor` to split the goal into two subset directions."
msgstr ""

#: Game.Levels.Sets.L10
msgid "Assume an arbitrary `x` and the hypothesis `h : x ‚àà A ‚à© (B ‚à™ C)`."
msgstr ""

#: Game.Levels.Sets.L10
msgid "Break the conjunction using `.left` and `.right` and `have`."
msgstr ""

#: Game.Levels.Sets.L10
msgid "`x ‚àà B ‚à™ C` is a disjunction. Use `cases` to split it."
msgstr ""

#: Game.Levels.Sets.L10
msgid "`x ‚àà B` holds. Combine with `x ‚àà A` using `left`, then use `constructor` to insert into `(A ‚à© B) ‚à™ (A ‚à© C)`."
msgstr ""

#: Game.Levels.Sets.L10
msgid "`x ‚àà C` holds. Combine with `x ‚àà A` using `right` and `constructor` to finish."
msgstr ""

#: Game.Levels.Sets.L10
msgid "Now assume `x ‚àà (A ‚à© B) ‚à™ (A ‚à© C)`. Use `cases` to split the disjunction."
msgstr ""

#: Game.Levels.Sets.L10
msgid "Construct `x ‚àà A ‚à© (B ‚à™ C)` by first proving `x ‚àà A`, then `x ‚àà B ‚à® C` using `left`."
msgstr ""

#: Game.Levels.Sets.L10
msgid "Continue to play around with `have`."
msgstr ""

#: Game.Levels.Sets.L10
msgid "Superb!\n"
"\n"
"You just proved one of the most important set identities: **distributivity of ‚à© over ‚à™**.\n"
"\n"
"This type of proof trains you to handle complex logical structure using simple steps ‚Äî a critical skill in discrete math."
msgstr ""

#: Game.Levels.Sets.Sets
msgid "Sets"
msgstr ""

#: Game.Levels.Sets.Sets
msgid "In this world, you'll explore the foundations of Sets.\n"
"\n"
"Each level presents a new fundamental theorem or principle.\n"
"\n"
"Before you start, take note of the panel on the right (if you are on PC). You can find the documentations/descriptions for several **Tactics** we will be making use of, and **Theorems** we will be proving(_and using_) in this World. Click on them, whether locked or unlocked, to read and understand! You are encouraged to do so whenever you are prompted to use a tactic in the game.\n"
"\n"
"Click on the `Start` button to begin!"
msgstr ""

#: Game.Levels.Induction.L01_
msgid "Base Case"
msgstr ""

#: Game.Levels.Induction.L01_
msgid "Welcome to the world of **Mathematical Induction**! üå±\n"
"\n"
"We'll begin by proving the **base case** of a simple statement:\n"
"\n"
"> For all natural numbers `n`, `n + 0 = n`\n"
"\n"
"This level focuses only on the **base case**, where `n = 0`."
msgstr ""

#: Game.Levels.Induction.L01_
msgid "`rfl` stands for ‚Äúreflexivity of equality‚Äù.\n"
"\n"
"It can be used when both sides of your goal are definitionally equal ‚Äî meaning Lean can reduce/simplify both sides to the same expression.\n"
"\n"
"You‚Äôll use `rfl` all the time to finish goals like `0 + 0 = 0`, `n = n`, etc."
msgstr ""

#: Game.Levels.Induction.L01_
msgid "You're trying to show `0 + 0 = 0`.\n"
"\n"
"Lean knows how to compute `0 + 0`, and simplifies it automatically using its built-in definition of addition.\n"
"\n"
"So simply type `rfl`."
msgstr ""

#: Game.Levels.Induction.L01_
msgid "Nice! You‚Äôve proven the base case. üéâ\n"
"\n"
"The next step is the **inductive step** ‚Äî where we assume the statement for `n` and prove it for `n + 1`."
msgstr ""

#: Game.Levels.Induction.L02_
msgid "Prove ‚àÄ n, n + 0 = n"
msgstr ""

#: Game.Levels.Induction.L02_
msgid "You‚Äôve seen the base case. Now let‚Äôs prove a **universal identity** using **mathematical induction**!\n"
"\n"
"We aim to prove:\n"
"\n"
"```lean\n"
"‚àÄ n : ‚Ñï, n + 0 = n\n"
"```\n"
"This means: for every natural number n, adding 0 on the right does not change the number.\n"
"\n"
"We‚Äôll proceed by induction on n.\n"
"\n"
"In this game, we are using our own custom natural numbers (‚Ñï) defined using MyNat.\n"
"Lean won't assume any built-in knowledge about +, so we prove everything from scratch!"
msgstr ""

#: Game.Levels.Induction.L02_
msgid "Use `induction n` to perform induction on `n`.\n"
"\n"
"It splits your goal into:\n"
"\n"
"--The base case (n = 0).\n"
"\n"
"--The inductive step, where you assume the statement for n (the induction hypothesis),\n"
"and prove it for succ n, i.e., the successor of n.\n"
"\n"
"Lean will automatically give names like `zero`, `succ`, and `ih`.\n"
"\n"
"Within the succ branch, use `rewrite (rw)` to apply previously proven theorems like add_succ\n"
"\n"
"Combine with the induction hypothesis to finish the proof\n"
"\n"
"Finally, `rfl` often concludes the goal once both sides match."
msgstr ""

#: Game.Levels.Induction.L02_
msgid "The `rw` tactic stands for **rewrite**.\n"
"\n"
"It allows you to replace part of your goal using a known equation.\n"
"\n"
"For example, if you have:\n"
"```lean\n"
"ih : k + 0 = k\n"
"and your goal is:\n"
"\n"
"succ (k + 0) = succ k\n"
"then:\n"
"\n"
"rw [ih]\n"
"will turn the goal into:\n"
"\n"
"succ k = succ k\n"
"```\n"
"which can then be solved using `rfl`.\n"
"\n"
"You can also use rewrite lemmas like `add_succ` or `add_zero`:\n"
"\n"
"```lean\n"
"rw [add_succ]\n"
"```\n"
"Lean replaces the left side using the definition:\n"
"```lean\n"
"succ n + m = succ (n + m)\n"
"```\n"
"You can rewrite multiple things:\n"
"```lean\n"
"rw [add_succ, ih]\n"
"```"
msgstr ""

#: Game.Levels.Induction.L02_
msgid "We want to prove this for all n. Use `intro n` first, then perform `induction n`."
msgstr ""

#: Game.Levels.Induction.L02_
msgid "This is the base case: `0 + 0 = 0`, which follows directly by definition.\n"
"\n"
"So you can do `rfl`, because that is exactly what you need to conclude the base case."
msgstr ""

#: Game.Levels.Induction.L02_
msgid "You're now in the inductive step.\n"
"\n"
"Your goal is:\n"
"```lean\n"
"succ k + 0 = succ k\n"
"```\n"
"Use the definition of addition:\n"
"```lean\n"
"succ k + 0 = succ (k + 0)\n"
"```\n"
"Then use the induction hypothesis:\n"
"```lean\n"
"ih : k + 0 = k\n"
"```\n"
"Applying only `rw` will solve it."
msgstr ""

#: Game.Levels.Induction.L02_
msgid "Fantastic! üéâ\n"
"\n"
"You‚Äôve completed a full induction proof.\n"
"\n"
"You showed:\n"
"\n"
"`0 + 0 = 0 (base case)`\n"
"\n"
"`succ k + 0 = succ k` assuming it was true for k (inductive step)\n"
"\n"
"This is how we prove facts for all natural numbers ‚Äî one step at a time!\n"
"\n"
"Ready for more? Let‚Äôs go!"
msgstr ""

#: Game.Levels.Induction.Induction
msgid "Mathematical Induction"
msgstr ""

#: Game.Levels.Induction.Induction
msgid "Welcome to the world of **Induction**!\n"
"\n"
"Mathematical Induction is a powerful proof technique used to show that a statement holds for all natural numbers.\n"
"\n"
"The basic structure of an induction proof involves:\n"
"1. **Base Case**: Show that the statement holds for the first natural number (usually 0 or 1).\n"
"2. **Inductive Step**: Assume it holds for an arbitrary `n`, and then prove it for `n + 1`.\n"
"\n"
"You'll begin with some classic induction formulas to get comfortable with the structure and reasoning process."
msgstr ""

#: Game
msgid "Discrete Mathematics with Lean 4"
msgstr ""

#: Game
msgid "Welcome to **Discrete Math with Lean 4**, an interactive game that will help you in proving several theorems of **Discrete Mathematics**\n"
"\n"
"**What is Lean?**\n"
"\n"
"Lean is a powerful tool used to write and verify mathematical proofs using code. It‚Äôs like a super-charged calculator for logic ‚Äî you tell Lean the rules and what you want to prove, and it checks every single step for correctness. Unlike doing math on paper (which can be vague), Lean makes sure there are no gaps or mistakes. It‚Äôs used by mathematicians, computer scientists, and even students to write formal, checkable proofs.\n"
"\n"
"Lean 4 is the latest version of the Lean theorem prover. It introduces a faster engine, better syntax, and allows users to build interactive proof environments ‚Äî like this game! Lean 4 also supports general-purpose programming, making it both a proof assistant and a full programming language. You can define logic, prove theorems, and even build applications ‚Äî all in one system.\n"
"\n"
"**What is this game all about?**\n"
"\n"
"This is a proof-based puzzle game built with Lean 4. Each level is a logic challenge. You solve it by using _tactics_ ‚Äî special instructions that Lean understands (just like any other programming language understanding its own syntax) ‚Äî to complete proofs step by step.\n"
"\n"
"Click on the World `Propositional`, to get started!"
msgstr ""

#: Game
msgid "This is the first iteration of this game. You can find the source code at [GitHub Repository ‚Äì gamemaker](https://github.com/shreyvivek/gamemaker)."
msgstr ""

#: Game
msgid "MH1812"
msgstr ""

#: Game
msgid "You can use this game as a template for your own game and add your own levels, if you are keen to learn more about Lean4."
msgstr ""
